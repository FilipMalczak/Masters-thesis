% compile with XeLaTeX
% !TeX spellcheck = pl_PL
% !TeX encoding = UTF-8
\documentclass[twoside]{iisthesis}
% ---
\usepackage[MeX]{polski}
%\usepackage[utf8]{inputenc}
\usepackage{graphicx}

\usepackage{fontspec}
\usepackage[table,xcdraw]{xcolor}

% Dodane przeze mnie d
\usepackage{fancyvrb} % dla srodowiska Verbatim
\usepackage{color}
\usepackage{lscape}

%pakiety do grafiki
\usepackage{pstricks}
\usepackage{pst-tree}

% definicje kolorow
\definecolor{ciemnoSzary}{rgb}{0.15,0.15,0.15}
\definecolor{szary}{rgb}{0.5,0.5,0.5}
\definecolor{jasnoSzary}{rgb}{0.2,0.2,0.2}
\definecolor{stal}{rgb}{0.75, 0.75, 0.75}

% Konfiguracja verbatima
\fvset{
	frame=single,
	numbers=left,
	fontsize=\footnotesize,
	numbersep=12pt,
%	framerule=.5mm,
	rulecolor=\color{ciemnoSzary},
%	fillcolor=\color{jasnoSzary},
	framesep=4pt,
	stepnumber=1,
	numberblanklines=false,
	tabsize=2,
%	formatcom=\color{szary}
}

% % % % % % % % % % % % % % % %
% MY CONTENT
% % % % % % % % % % % % % % % %


\usepackage{tabularx}
\usepackage{tabulary}
\usepackage{placeins}
\usepackage{algpseudocode}
\usepackage[chapter]{algorithm}
\usepackage{mathtools}
\usepackage{float}
\usepackage{tocloft}
%\usepackage{tocbibind}
\usepackage{amsfonts}
\usepackage{nicefrac}

\usepackage[labelsep=period]{caption}

\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{decorations.pathreplacing}

\usepackage{wasysym}

\algnewcommand\Var{\State\textbf{var\ }}
\algnewcommand\To{\textbf{ to }}

\algnewcommand{\Description}[2]{%
	\Statex \textbf{#1:}
	\Statex \hspace*{\algorithmicindent}\parbox[t]{.8\linewidth}{\raggedright #2}
}
\algdef{SE}[OPERATOR]{Operator}{EndOperator}%
[2]{\textbf{operator}\ \textproc{#1}\ifthenelse{\equal{#2}{}}{}{(#2)}}%
{\algorithmicend\ \textbf{operator}}

\algnewcommand{\Input}[1]{\Description{Wejście}{#1}}
\algnewcommand{\Output}[1]{\Description{Wyjście}{#1}}
\algnewcommand{\Params}[1]{\Description{Parametry}{#1}}
\algnewcommand{\Context}[1]{\Description{Dostępne zmienne}{#1}}

\algnewcommand{\Start}{\setcounter{ALG@line}{-1}}


%\algnewcommand{\MyComment}[1]{\Comment{\parbox[t]{.5\linewidth}{#1}}}
%\algnewcommand{\MyComment}[1]{\Comment{\begin{flushright}#1\end{flushright}}}
%\algnewcommand{\MyComment}[1]{\Comment{\begin{flushright}\parbox[t]{\linewidth}{#1}\end{flushright}}}
%\algnewcommand{\MyComment}[1]{\begin{flushright}$\rhd$\quad #1\end{flushright}}
%\algnewcommand{\MyComment}[1]{\parbox[t]{\linewidth}{\begin{flushright}$\rhd$\quad #1\end{flushright}}}

\newcommand{\defacto}{\emph{de facto }}
\newcommand{\ergo}{\emph{ergo }}
\newcommand{\Defacto}{\emph{De facto }}
\newcommand{\Ergo}{\emph{Ergo }}

\newcommand{\todo}{\colorbox{red}}
\newcommand{\fixme}{\colorbox{blue}}

\newfloat{signature}{h}{sig}
\floatname{signature}{Sygnatura}

\floatname{algorithm}{Algorytm}


\newcommand{\numberSet}[1]{\mathbb{#1}}
\newcommand{\important}[1]{\mathcal{#1}}
\newcommand{\R}{\mathbf{R}}
\newcommand{\minorityEvalRel}{{\R}_{\prec}}
\newcommand{\minoritySpecimenRel}{{\R}_{\lhd}}
\newcommand{\param}[1]{\mathtt{#1}}
\newcommand{\variable}[1]{\mathsf{#1}}
\newcommand{\opName}[1]{\textproc{#1}}
%\newcommand{\variable}[1]{\textbf{#1}}
%\newcommand{\inputVar}[1]{\variable{#1_{I}}}
%\newcommand{\outputVar}[1]{\variable{#1_{O}}}
\newcommand{\inputVar}[1]{\variable{\overline{#1}}}
\newcommand{\outputVar}[1]{\variable{\underline{#1}}}

\newcommand{\withSize}[2]{{#1}^{ \{ #2 \}}}
\newcommand{\range}[2]{\langle#1, #2\rangle}

%\newcommand{\circled}[1]{\textcircled{\small{#1}}}
%\newcommand{\circled}[1]{\tikz \node[anchor=south west, draw,circle, inner sep=0pt, minimum size=7mm, pos=0.5]{#1};}
\newcommand{\circled}[1]{ \textcircled{\scriptsize{#1}} } 


\newcommand{\img}[1]{\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{pictures/#1}}
\newcommand{\graph}[1]{\input{graphs/#1}}
%\newcommand{\vectorGraphics}[1]{\input{vector/#1}}

\newcolumntype{s}{>{\hsize=.5\hsize}c}

%\newcommand{\largeVMiddle}[2][|]{ \multicolumn{1}{#1m#1}{ \Large #2 \par } }

%uncomment for double spacing 
%\usepackage{setspace}
%\doublespacing

\begin{document}

\title{Algorytmy ewolucyjne z uwzględnieniem płci w rozwiązywaniu wybranych problemów}
\author{Filip Malczak}
\advisor{dr hab. inż. Urszula Markowska-Kaczmar}
\instituteLogo{logos/pwr}
\slowaKluczowe{algorytmy ewolucyjne\\płeć\\operator selekcji}

\date{\number\the\year}

% Wstawienie abstractu pracy
	%\input {abstract}
	
\abstractSH{
Bardzo krótkie streszczenie w którym powinno się znaleźć omówienie tematu pracy i poruszanych terminów. Tekst ten nie może być zbyt długi. 
}

\abstractPL{
	Abstrakt
}
\abstractEN{
	Abstrakt
}

\maketitle
\textpages

\chapter{Wprowadzenie}

Optymalizacja to zadanie wyboru najlepszego elementu z danego zbioru (nazywanego przestrzenią rozwiązań). 
Przez najlepszy rozumiemy taki, dla którego tzw. funkcja oceny, czy też kryterium przyjmuje najwyższą (w zadaniu maksymalizacji) lub najniższą (w zadaniu minimalizacji) wartość. 
Z takim problemem spotykamy się wszędzie tam, gdzie chcemy zwiększyć lub zmniejszyć jakieś wskaźniki, np. zminimalizować koszta produkcji lub transportu, albo zmaksymalizować zyski ze sprzedaży lub jakość klasyfikacji.

Jeżeli funkcję oceny można zapisać w postaci analitycznej (np. w formie układu równań różniczkowych) to zazwyczaj możemy ją optymalizować metodami numerycznymi, analitycznymi lub algebraicznymi. 
Istnieją sytuacje, w których nie możemy skorzystać z żadnej z tych metod. 
Powody tego mogą być różne, m.in. możemy nie znać postaci funkcji (bo np. reprezentuje ona obserwacje jakiegoś procesu lub zjawiska), funkcja zapisana analitycznie może nie spełniać pewnych kryteriów (np. nie być różniczkowalna), lub obliczenia mogą zajmować zbyt wiele czasu (np. pełne przeszukiwanie przestrzeni rozwiązań będącej iloczynem kartezjańskim dużej liczby dużych, czy wręcz nieskończonych zbiorów). 
Często nie jest nam potrzebne globalne optimum (tzn najlepsze rozwiązanie ze wszystkich możliwych), a wystarczy rozwiązanie jak najlepsze (tzn. optimum lokalne, lub punkt o wartości kryterium zbliżonej do wartości kryterium optimum globalnego).

Do takich zastosowań przeznaczone są metody nazywane heurystykami. 
W zależności od źródła definicje tego pojęcia są różne. 
W dziedzinie informatyki, a w szczególności obliczeń miękkich i sztucznej inteligencji, termin ten możemy nieformalnie opisać jako algorytm który nie daje gwarancji uzyskania poprawnego wyniku, ale z większym prawdopodobieństwe zwróci wyniki ,,lepsze''.
Heurystyki stosowane są wszędzie tam, gdzie nie mamy rzeczywistej możliwości uzyskania wyniku, więc dowolne jego przybliżenie będzie lepsze niż brak jakichkolwiek rezultatów.

\section{Algorytmy ewolucyjne} \label{section:eaShortDesc}

Ewolucja to proces zachodzący w naturze odpowiedzialny za dopasowywanie się osobników danego gatunku do środowiska w jakim żyją. 
Podstawą tego procesu jest zasada przetrwania lepiej przystosowanych osobników oraz zjawiska dziedziczenia i mutacji.

Zgodnie z powyższą zasadą, jednostki lepiej dopasowane do środowiska mają większą szansę na przeżycie, a co za tym idzie, na wydanie potomstwa.
Oznacza to, że rodzice większości osobników z kolejnego pokolenia będą radzić sobie w tym środowisku lepiej niż pozostała część populacji.

Zjawisko dziedziczenia polega na przekazywaniu cech rodziców dzieciom. 
Zachodzi ono podczas rozmnażania, a więc między dwojgiem rodziców i ich potomstwem. 
Kod genetyczny potomstwa tworzony jest przez losowe łączenie odpowiednich części kodu genetycznego rodziców, dzięki czemu kolejne pokolenie dzieli ich cechy. 
W ten sposób niektóre osobniki przejmą od rodziców te cechy, które pozwalały im się dopasować do środowiska.
Część osobników przejmie jednak nie tylko cechy poprawiające ich szansę przetrwania, ale również cechy negatywne, co przełoży się na ich gorsze dopasowanie.

Mutacja to zjawisko zachodzenia losowych zmian w kodzie genetycznym osobnika, dzięki którym ma on szansę zyskać nowe cechy, co w niektórych przypadkach doprowadzi do lepszego dopasowania.
Osobniki z przypadkowymi zmianami, które poprawiają ich dopasowanie mają większe szanse na przeżycie i wydanie potomstwa.
Zmiany te więc zostać rozpropagowane wśród osobników przyszłych pokoleń.

Algorytmy ewolucyjne to rodzina heurystyk naśladujących proces ewolucji w celu optymalizacji \cite{davis1991handbook}. 
Pojedynczy element przestrzeni rozwiązań jest w nich nazywany osobnikiem. 
Osobniki możemy między sobą porównywać pod względem wartości optymalizowanej funkcji dla nich, a relacja mniejszości (dla problemów minimalizacji) lub większości (dla problemów maksymalizacji) reprezentuje relację bycia lepiej przystosowanym do środowiska. 
Ponadto, na osobnikach określone są operatory mutacji i krzyżowania, które mają na celu symulację odpowiednich zjawisk występujących w przyrodzie. 
Heurystyka polega na wielokrotnym przetworzeniu populacji (czyli zbioru osobników) poprzez zastosowanie każdego z operatorów z pewnym prawdopodobieństwem. 
W każdym kroku (nazywanym w tym przypadku pokoleniem) do dotychczasowej populacji dołączane są wyniki ich działania tych operatorów, a następnie wybierana jest nowa populacja, używana w kolejnym kroku. 
Aby odwzorować zasadę przetrwania najlepiej dopasowanych osobników, do kolejnej populacji wybierane są z wyższym prawdopodobieństwem osobniki lepiej przystosowane.

W naturze rozmnażanie się osobników wielu gatunków jest ściśle związane ze zjawiskiej podziału gatunku na płcie. 
Bardziej szczegółowy opis tego zjawiska znajduje się w rozdziale \ref{chapter:proposed}. 
W dostępnej literaturze dotyczącej tematu algorytmów ewolucyjnych rzadko można znaleźć prace, w których uwzględnia się ten aspekt procesu ewolucji (patrz: rozdział \ref{chapter:literature}). 
Powodem tego jest raczej chęć uproszczenia działania samej heurystyki niż lepsza jakość wyników uzyskiwanych z pominięciem tego aspektu (\cite{GGA}, \cite{SexualGA}). 

\section{Cele pracy}

Pierwszym celem niniejszej pracy jest opracowanie formalnego opisu algorytmu ewolucyjnego uwzględniającego płeć.
Schemat heurystyki jest w pewnym stopniu dowolny, a publikacje z tej dziedziny nie używają jednego wspólnego formalizmu, co utrudnia jednoznaczne porównywanie ich działania.
Spełnienie tego celu powinno doprowadzić do określenia konkretnego schematu, który pozwoli zaimplementować wybrane istniejące rozwiązania oraz zaproponowane rozwiązanie autorskie.

Kolejnym celem jest opis i implementacja wybranych istniejących rozwiązań wykorzystujących płeć w ramach wcześniej opisanego schematu.
Poza implementacją tych metod, powinno powstać narzędzie badawcze, które pozwoli na klarowne porównanie ich działania.

Cel trzeci to opracowanie i implementacja nowego podejścia uwzględniającego płeć.
Jest to główny cel tej pracy, mający wnieść coś nowego do dziedziny algorytmów ewolucyjnych.

Ostatnim celem jest zbadanie wcześniej opisanych i zbadanych podejść.
Polega to na zebraniu miar jakości działania algorytmów ewolucyjnych dla każdego z nich i porównaniu ich ze sobą.

\chapter{Algorytmy ewolucyjne} \label{chapter:eaDesc}

Ten rozdział ma na celu opisanie zagadnienia algorytmów ewolucyjnych, zaczynając od ogólnych informacji, stopniowo przechodząc do szczegółów.
W pierwszej jego części opisana jest ogólna idea tych heurystyk. 
Kolejna sekcja skupia się na formalnym opisie poszczególnych pojęć.
Po niej znajduje się część w której znajdziemy szczegóły idei opisanej na początku, zapisane z użyciem pojęć przedstawionych w sekcji drugiej.
Całość zostanie zamknięta opisem sposobów oceny i analizy działania algorytmów ewolucyjnych.

\section{Idea algorytmów ewolucyjnych} \label{section:general_idea}

Podstawowym pojęciem używanym w opisywanej heurystyce jest \emph{osobnik}. 
Jest to abstrakcja pojedynczego rozwiązania, nawiązująca do pojedynczego żywego stworzenia charakteryzującego się pewnymi cechami które wpływają na prawdopodobieństwo jego przeżycia i wydania potomstwa. 
Pojęciem symulującym wpływ cech na prawdopodobieństwo przeżycia jest \emph{funkcja oceny}. 
Dodatkowo wprowadzamy pojęcie \emph{populacji}, czyli zbioru osobników istniejących w danym momencie w procesie ewolucji.

Realizacją osobnika w heurystyce jest reprezentacja rozwiązania problemu, a realizacją populacji - zbiór rozwiązań, czyli podzbiór przestrzeni rozwiązań.
Populację możemy też rozumieć jako zbiór próbek z pewnej podprzestrzeni zbioru rozwiązań.

Przez pojęcie funkcji oceny (nazywanej też kryterium) rozumiemy pewne przyporządkowanie (w idealnej sytuacji - funkcję, jednak nie zawsze jest to możliwe; patrz: rozdział \ref{subsection:specimen_and_foo}) każdemu osobnikowi, czyli rozwiązaniu problemu, jakiejś wartości, na której możemy określić porządek.
Taka relacja porządku powinna określać czy dane rozwiązanie jest równie dobre lub lepsze niż inne, czy nie.

Standardową realizacją osobnika jest wektor binarny, który sprawdza się w wielu zastosowaniach i jest prosty w realizacji programowej lub sprzętowej. 
Algorytmy ewolucyjne korzytające z takiej reprezentacji nazywane są algorytmami genetycznymi. 
Reprezentacja jest jednak uzależniona od rozwiązywanego problemu. 
Często wykorzystuje się bardziej skomplikowane przedstawienia rozwiązania, jak wektor wartości z pewnego zbioru (skończonego, lub nieskończonego, jak liczby), czy drzewo \cite{gen_prog} (np. dla problemów aproksymacji funkcji, przedstawionych jako zadanie minimalizacji błędu przybliżenia \cite{gen_prog_foo_approx}).

Istnieją implementacje i narzędzia do obliczeń ewolucyjnych które rozróżniają pojęcie genotypu osobnika (czyli wewnętrznej reprezentacji rozwiązania, na której stosujemy operatory genetyczne takie jak krzyżowanie i mutacja) i jego fenotypu (czyli reprezentacji zewnętrznej, na podstawie której oceniamy osobnika), jednak jest to jedynie abstrakcja umożliwiająca czytelniejsze zapisanie realizacji odpowiednich pojęć w języku programowania. Niniejsza praca nie wprowadza takiego rozróżnienia, ponieważ nie zmienia ono w żadnym stopniu jakości działania heurystyki i nie jest związane z tematem badań.

Na rysunku \ref{figure:ea_general} zobrazowany został ogólny schemat działania algorytmów ewolucyjnych. Formalny opis używanych parametrów i operatorów znajduje się w kolejnej sekcji, wraz z definicją takich pojęć jak np. operator.

\begin{figure}
	\caption{Ogólny schemat działania algorytmów ewolucyjnych
		\label{figure:ea_general}
		}
	\img{ea_general.png}
	Konwencje dotyczące rysowania schematów blokowych zostały wyjaśnione w podsekcji \ref{subsection:conventions}.
\end{figure}

Współczesna nauka dalej nie jest w stanie dać nam odpowiedzi na pytanie ,,skąd wzięło się życie'', a co za tym idzie, nie jesteśmy w stanie zasymulować momentu rozpoczęcia ewolucji.
Zamiast tego, w heurystykach naśladujących ten proces działanie zaczyna się od wygenerowania losowej populacji, czyli zbioru osobników. 
Symuluje to w uproszczony sposób analizę ewolucji od przypadkowego momentu w czasie istnienia gatunku.
Biorąc pod uwagę, że celem heurystyki nie jest idealnie wierne odtworzenie warunków naturalnych, a optymalizacja, nie wydaje się to być problemem.

Mając zbiór początkowych osobników (czyli rozwiązań naszego problemu) rozpoczynamy proces przeszukiwania ich przestrzeni.
Dzieje się to iteracyjnie, co znaczy, że pewien zestaw kroków jest wielokrotnie powtarzany.
Jedno takie powtórzenie jest nazywane \emph{generacją} lub \emph{pokoleniem}, a składa się na nie kolejno krzyżowanie, mutacja i selekcja naturalna.
Moment w którym należy przerwać proces optymalizacji jest wybierany przez kryterium przerwania. 
Nie ma to przełożenia na naturę (jako, że ewolucja teoretycznie nigdy się nie kończy) i jest jedynie narzędziem które ma sprawić, że heurystyka nie będzie działać wiecznie, tylko w skończonym czasie zwróci interesujące nas wyniki.

Na pojedyncze pokolenie składają się 3 główne kroki: krzyżowanie, mutacja i selekcja. 
Mają one symulować odpowiednie zjawiska występujące w przyrodzie - kolejno dziedziczenie, mutację i przetrwanie lepiej dopasowanych osobników.
Pierwsze dwa z nich kontrolują tempo przeszukiwania przestrzeni rozwiązań, a ostatnie steruje przeszukiwaniem tak, aby odnajdywać jak najlepsze rozwiązania. 

Krzyżowanie odbywa się przy pomocy dedykowanego operatora, z częstością określoną odpowiednim prawdopodobieństwem.
Polega ono na wybraniu losowych par osobników nazywanych rodzicami i dołączeniu do populacji nowych rozwiązań (nazywanych potomstwem), o reprezentacji zbliżonej do reprezentacji rodziców.
Ma to symulować dziedziczenie cech rodziców przez ich potomków.
Zadaniem krzyżowania jest eksploatacja przestrzeni rozwiązań, poprzez zbadanie punktów, które znajdują się pomiędzy znanymi nam już rozwiązaniami.
Dzięki temu zagęszczamy próbkowanie podprzestrzeni, którą już zbadaliśmy, czyli dotychczasowej populacji, co ma na celu znalezienie potencjalnych optimów, które mogły zostać przeoczone przez zbyt rzadkie próbkowanie.

Jedną z popularnych realizacji operatora krzyżowania dla osobnika reprezentowanego jako wektor jest wybranie losowej pozycji w wektorach opisujących rodziców (tzw. punktu przecięcia) i zwrócenie 2 osobników powstałych przez zamianę podwektorów od wylosowanej pozycji wzwyż. 
Na rysunku \ref{vector:example_crossover} zobrazowano działanie takiego podejścia. 
Wektory $(x_0, \ldots, x_9)$ i $(y_0, \ldots, y_9)$ to przykładowi rodzice. 
Grubą linią zaznaczono wylosowany punkt przecięcia, wyznaczający podwektory które zostają zamienione. 
Wektory $(x_0, \ldots, x_3, y_4, \ldots y_9)$ i $(y_0, \ldots, y_3, x_4, \ldots x_9)$ są wtedy traktowane jako potomstwo.

\begin{figure}[h]
	\caption{Działanie przykładowej realizacji operatora krzyżowania \label{vector:example_crossover}}
	\centering
	\begin{tikzpicture}[>=triangle 60]
	\tikzstyle{cellStyle}=[draw, rectangle, minimum width=1cm, minimum height=1cm, text centered, draw=black]
	\tikzstyle{first}=[cellStyle, fill=gray!30]
	\tikzstyle{second}=[cellStyle, fill=gray!70]
	
	%first input
	\foreach \x in {0,1,...,9}
	\node[first] at (\x, 0) {$x_\x$};
	
	%second input	
	\foreach \x in {0,1,...,9}
	\node[second] at (\x, -1.5) {$y_\x$};
	
	%swap arrow
	\draw[<->, >=latex', shorten >=2pt, shorten <=2pt, bend left=45, ultra thick] 
	(10, 0) to (10, -1.5); 
	
	%input cutpoint
	\draw[ultra thick] (3.5, 1) -- (3.5, -2.5);
	
	%operator arrow
	\draw [->, thick] (4.5, -2.5)  -- (4.5, -4.5); 
	\node[right] at (4.5, -3.5) {$\param{opKrzyzowania}$};
	
	%first output
	\foreach \x in {0,1,...,3}
	\node[first] at (\x, -5.5) {$x_\x$};
	\foreach \x in {4,5,...,9}
	\node[second] at (\x, -5.5) {$y_\x$};
	
	%second output
	\foreach \x in {0,1,...,3}
	\node[second] at (\x, -7) {$y_\x$};
	\foreach \x in {4,5,...,9}
	\node[first] at (\x, -7) {$x_\x$};
	
	%output cutpoint
	\draw[ultra thick] (3.5, -4.5) -- (3.5, -8);
	\end{tikzpicture} 
\end{figure}

Kolejnym krokiem w każdym pokoleniu jest mutacja, czyli wprowadzenie losowych zmian w losowo wybranych osobnikach. 
Jest to wykonywane przy pomocy odpowiedniego operatora, z prawdopodobieństwem określającym szansę osobnika na zmutowanie.
Zmodyfikowane osobniki w zależności od implementacji są dołączane do populacji, albo zastępują niezmodyfikowane rozwiązania.
W tej pracy wykorzystano pierwszą z tych opcji, aby nie doprowadzić do sytuacji, w której mutacja pogorszy znane rozwiązanie, które zostanie odrzucone z populacji (ponieważ na jego miejsce wejdzie rozwiązanie zmodyfikowane).
Zadaniem tego kroku jest eksploracja przestrzeni rozwiązań, czyli zbadanie rozwiązań spoza dotychczas spróbkowanej podprzestrzeni.
W ten sposób heurystyka przeszukuje nowe obszary, które potencjalnie zawierają optimum globalne, a przynajmniej optima lokalne lepsze od dotychczas znalezionych. 

Jedną z popularnych realizacji operatora mutacji dla osobnika reprezentowanego jako wektor bitów jest negacja losowych wartości, w wyniku czego otrzymujemy osobniki różniące się od argumentu operatora tylko kilkoma elementami. Na rysunku \ref{vector:example_mutation} zobrazowano działanie takiego podejścia. Wektor $(1, 0, 0, 1, 1, 1, 0, 0, 1, 0)$ to argument operatora. Kolorem zaznaczono losowe pozycje w wektorze, które zostaną zanegowane, w wyniku czego powstanie wektor wyjściowy $(1, \textbf{1}, 0, 1, \textbf{0}, 1, 0, 0, 1, \textbf{1})$.

\begin{figure}[h]
	\caption{Działanie przykładowej realizacji operatora mutacji \label{vector:example_mutation}}
	\centering
	\begin{tikzpicture}[>=triangle 60]
	\tikzstyle{cellStyle}=[draw, rectangle, minimum width=1cm, minimum height=1cm, text centered, draw=black]
	\tikzstyle{mutated}=[cellStyle, fill=gray!50]
	
	%original
	\node[cellStyle] at(0, 0) {$1$};
	\node[mutated] at(1, 0) {$0$};
	\node[cellStyle] at(2, 0) {$0$};
	\node[cellStyle] at(3, 0) {$1$};
	\node[mutated] at(4, 0) {$1$};
	\node[cellStyle] at(5, 0) {$1$};
	\node[cellStyle] at(6, 0) {$0$};
	\node[cellStyle] at(7, 0) {$0$};
	\node[cellStyle] at(8, 0) {$1$};
	\node[mutated] at(9, 0) {$0$};
	
	%operator arrow
	\draw [->, thick] (4.5, -1)  -- (4.5, -3); 
	\node[right] at (4.5, -2) {$\param{opMutacji}$};
	
	%mutated
	\node[cellStyle] at(0, -4) {$1$};
	\node[mutated] at(1, -4) {$1$};
	\node[cellStyle] at(2, -4) {$0$};
	\node[cellStyle] at(3, -4) {$1$};
	\node[mutated] at(4, -4) {$0$};
	\node[cellStyle] at(5, -4) {$1$};
	\node[cellStyle] at(6, -4) {$0$};
	\node[cellStyle] at(7, -4) {$0$};
	\node[cellStyle] at(8, -4) {$1$};
	\node[mutated] at(9, -4) {$1$};				
	
	\end{tikzpicture} 
\end{figure}

Zmiany zachodzące w jednym osobniku nie powinny być zbyt drastyczne (tak, aby był on zbliżony w reprezentacji do pierwotnego osobnika), ale też nie mogą być zbyt mało znaczące, ponieważ znacząco spowolniłoby to proces eksploracji, a co za tym idzie, obniżyłoby efektywność heurystyki.
Gdyby przykładowy operator mutacji (z rysunku \ref{vector:example_mutation})) operował na wektorach o długości rzędu kilku tysięcy, to zamiana pojedynczego bitu byłaby zbyt mało znacząca, ponieważ rozwiązania przed i po jego zastosowaniu praktycznie by się od siebie nie różniły.
Jeśli jednak operator zmieniałby około połowy bitów, to nowe rozwiązanie byłoby zbyt dalekie od pierwotnego, przez co heurystyka sprowadziłaby się do kompletnie losowego przeszukiwania przestrzeni rozwiązań.

W zależności od implementacji oba operatory opisane powyżej mogą być stosowane w różnej kolejności.
Ponadto, od realizacji zależy to, czy mutacja jest stosowana jedynie na populacji z poprzedniego pokolenia, czy również na potomstwie.
W tej pracy przyjmuje się, że krzyżowanie zostaje wykonane przed mutacją, a jego wyniki również mogą być przez nią modyfikowane.
Dzięki temu próbkowanie przestrzeni rozwiązań jest gęstsze, niż gdybyśmy postępowali w inny sposób.

Te dwa kroki mają na celu losowe przeszukiwanie przestrzeni rozwiązań.
Gdyby ograniczyć się jedynie do nich, to heurystyka nie dawałaby pożądanych wyników.
W celu dojścia do optimów należy tą losowość jakoś ukierunkować.
Jest to powód, dla którego na końcu każdego pokolenia do całej populacji (a więc osobników z początku pokolenia, potomstwa i osobników zmutowanych) stosuje się operator selekcji naturalnej.
Jego zadaniem jest wybranie ze znanych rozwiązań tych, które są lepsze w sensie rozwiązywanego problemu.
Zostaną one wykorzystane jako populacja używana w kolejnym pokoleniu. 
Intuicyjnie, operator ten pełni rolę negatywnych czynników środowiskowych, które sprawiają, że nie wszystkie osobniki danego gatunku przeżywają.
Zgodnie z prawami rządzącymi naturą, większe prawdopodobieństwo przeżycia powinny mieć jednostki lepiej dopasowane do swojego środowiska, co w heurystyce przekłada się na lepszą (mniejszą, lub większą, w zależności od rozwiązywanego zadania) funkcję oceny.

Najprostszym operatorem selekcji jest tzw. operator elitarny (nazywany też elitystycznym), którego działanie polega na zwróceniu określonej liczby bezwzględnie najlepszych osobników z dotychczasowej populacji.
Mimo, że wydaje się to intuicyjne, to nie jest to rozwiązanie idealne.
Praktyka pokazuje, że rozwiązania gorsze często mają cechy, które w dalszych pokoleniach, po kolejnych modyfikacjach, dają rozwiązania lepsze od dotychczasowych.
Jest to powodem istnienia takich realizacji jak np. selekcja turniejowa, czy ruletkowa (opisane w rozdziale \ref{chapter:experiments} w ramach opisu implementacji).

Tak sformułowany proces służy do efektywnego przeszukiwania przestrzeni rozwiązań, tymczasem zadanie optymalizacji ma na celu znalezienie jak najlepszego z nich.
Oznacza to, że jedno z rozwiązań, które zostanie zbadane w trakcie działania heurystyki musi być zapamiętane i zwrócone jako wynik. 
Naiwnym podejściem jest analiza populacji po ostatnim pokoleniu i zwrócenie najlepszego z osobników. 
Jako, że operator selekcji nie gwarantuje tego, że w zbiorze wynikowym znajdzie się najlepszy osobnik ze zbioru wejściowego, to istnieje szansa, że najlepsze rozwiązanie z ostatniej populacji nie jest najlepszym rozwiązaniem znalezionym w trakcie działania heurystyki. 
Zamiast tego w trakcie symulacji zapamiętujemy globalnie najlepsze rozwiązanie na jakie trafiliśmy i właśnie je traktujemy jako rozwiązanie problemu optymalizacji.
Zazwyczaj realizuje się to w ten sposób, że definiuje się zmienną przechowującą globalne optimum\footnote{
	W tym kontekście optima globalne i lokalne oznaczają najlepsze dotychczas znalezione rozwiązanie i najlepsze rozwiązanie w danej populacji.
}, która początkowa ma wartość pustą.
Po zakończeniu pierwszego pokolenia, ale przed zastosowaniem operatora selekcji, zapisuje się w niej najlepsze rozwiązanie w tym pokoleniu.
W tym samym momencie w dalszych pokoleniach porównuje się ocenę obecnego globalnego optimum i najlepszego osobnika z danego pokolenia (optimum lokalnego). 
Jeśli optimum globalne jest gorsze niż lokalne, to zostaje nim zastąpione.

\section{Formalny opis operatorów i parametrów}

Niniejsza sekcja jest przeznaczona na formalny opis elementów algorytmu ewolucyjnego.
Jak zostało zaznaczone w poprzedniej sekcji, sam schemat działania heurystyki zależy od implementacji, jednak pokazane tu definicje i sygnatury powinny być zgodne z większością istniejących rozwiązań.
Każde z opisywanych pojęć niesie ze sobą nie tylko znaczenie i zastosowanie wzorowane na przyrodzie, ale również ograniczenia nałożone na realizację danego elementu, również wynikające z natury.
Wszystkie te aspekty zostaną podane i zapisane w formie, która ma zapobiec występowaniu nieścisłości.

W pierwszej podsekcji zajduje się zestaw konwencji związanych z diagramami, czcionkami, itd. używanymi w tej pracy. Normy te obowiązują w całym dokumencie, również w poprzednich sekcjach i rozdziałach.

Druga podsekcja opisuje pojęcie operatora, które jest często stosowane przy formalnych opisach elementu heurystyki. Dodatkowo, znajdziemy tam definicję operatora $random(X)$, który jest bardzo przydatny w dalszych opisach.

Kolejne pięć podsekcji skupia się już na konkretnych częściach heurystyki, które należy określić w celu jej wykorzystania.

\subsection{Konwencje} \label{subsection:conventions}

W tabeli \ref{table:signature_conventions} zostały pokazane konwencje dotyczące znaczenia czcionek używane w tej pracy.

\begin{table}[b]
	\caption{Konwencje dotyczące czcionek \label{table:signature_conventions}}
	\centering
	\begin{tabular}{cl}
		$\param{operator}, \param{n}$ & operatory i parametry heurystyki \\
		$\variable{k}$ & parametry zależne od realizacji operatorów \\
		$T, p$ & zbiory i parametry pomocnicze \\
		$\important{S}$ & zbiory używane w definicjach \\
		$\R$ & relacje \\
		$\numberSet{N}$ & zbiory liczbowe
	\end{tabular}
\end{table}

Na rysunku \ref{figure:flowchart_conventions} zobrazowane zostały różne elementy schematów blokowych używane w tej pracy, opisane w tabeli \ref{table:flowchart_conventions}.

\begin{figure}
	\caption{Konwencje dotyczące elementów schematów blokowych \label{figure:flowchart_conventions}}
	\img{conventions.png}
\end{figure}

\begin{table}
	\caption{Opis konwencji dotyczących elementów schematów blokowych \label{table:flowchart_conventions}}
	\begin{tabularx}{\linewidth}{|c|X|}
		\hline 
		\circled{1} & Symbol rozpoczęcia heurystyki. \\
		\hline
		\circled{2} & Symbol rozpoczęcia heurystyki. \\
		\hline
		\circled{3} & Symbol oznaczający ewaluację warunku C i kontynuację procesu zgodnie z jego wynikiem. \\
		\hline
		\circled{4} & Symbol oznaczający wykonanie kroku opisanego przez S. \\
		\hline
		\circled{5} & Symbol tożsamy z symbolem \circled{4}, jednak stosowany w opisie proponowanego podejścia dla zaznaczenia różnic ze standardowym schematem (używane w rozdziale \ref{chapter:proposed}).\\
		\hline
		\circled{6} & Kombinacja symboli oznaczająca, że podczas wykonywania kroku S używany jest operator O. \\
		\hline
		\circled{7} & Kombinacja symboli oznaczająca, że podczas wykonywania kroku S używany jest parametr P. \\
		\hline
		\circled{8} & Symbol oznaczający, że dany schemat wyjaśnia szczegółowe działanie kroku D. \\
		\hline
		\circled{9} & Symbol oznaczający rozpoczęcie lub zakończenie szczegółowo opisywanego kroku. \\
		\hline
		\circled{10} & Symbol oznaczający wykonanie kolejnego symbolu dla każdego z elementów opisanych przez E. \\
		\hline
	\end{tabularx}
\end{table}

Na rysunku \ref{plot:conventions} przedstawiono konwencje dotyczące rysowania wykresów przyjęte w tym dokumencie.

\begin{figure}
	\caption{Konwencje dotyczące rysowania wykresów \label{plot:conventions}}
	\centering
	\graph{example_whiskers.tex}
\end{figure}

Ponadto, w sygnaturach operatorów i funkcji będą często wykorzystywane klasy zbiorów o konkretnym rozmiarze. Jako, że nie istnieje powszechnie przyjęta konwencja zapisu takiego bytu, w niniejszej pracy przyjęto, że zapis $\withSize{A}{n}$ oznacza klasę zbiorów $n$elementowych, w której każdy element należy do zbioru $A$. Zapis $A^n$, zgodnie ze standardową konwencją oznacza $n$krotny iloczyn kartezjański zbioru $A$, czyli klasę wektorów o długości $n$, których składowe pochodzą ze zbioru $A$.

\begin{align}
	\withSize{A}{n} \equiv &\{ a: a \subset A, |a|=n  \} \\
	\withSize{A}{0} \equiv &\emptyset \\
	A^n \equiv &\underbrace{A \times A \times \ldots \times A}_{n} \\
	A^0 \equiv &\emptyset \\
	A \times B \equiv &\{ (a, b): a \in A, b \in B \}
\end{align}

\subsection{Pojęcie operatora} \label{subsection:operator}

W dalszych rozdziałach będziemy używać pojęcia ,,\textbf{operator}'', które jest zbliżone do pojęcia funkcji. Różnica między tymi dwoma terminami jest taka, że funkcja musi zawsze zwrócić tą samą wartość dla tego samego argumentu, podczas gdy takie ograniczenie nie musi być spełnione dla operatora. Innymi słowy pojęcie operatora pokrywa się z pojęciem funkcji z imperatywnych języków programowania, ale nie jest tożsame z funkcją w rozumieniu matematycznym.

Operator możemy też rozumieć jako zmienną losową opisaną rozkładem parametryzowanym jego argumentami.

Warto pamiętać, że każda funkcja (w rozumieniu matematycznym) jest operatorem.

Do operatorów możemy stosować niektóre pojęcia używane w stosunku do funkcji. Przez \emph{dziedzinę} operatora rozumiemy przestrzeń dozwolonych argumentów operatora, a przez \emph{przeciwdziedzinę} - zbiór wartości które może zwrócić. Aby uzyskać \emph{wynik} operatora (czyli wartość przez niego zwracaną) \emph{stosujemy} ten operator na \emph{argumentach}.

Dodatkowo, operator możemy \emph{sparametryzować} aby uzyskać inny operator. Przez \emph{parametry} rozumiemy argumenty które w ramach danego ciągu obliczeń są stałe. Przykładowo, operator sąsiedztwa o określonym rozmiarze \emph{d} dla punktu \emph{(x, y)}:

\begin{displaymath}
	sasiedztwo((x, y), d) \in [x-d, x+d] \times [y-d, y+d]
\end{displaymath}

możemy sparametryzować rozmiarem sąsiedztwa, aby uzyskać operator sąsiedztwa o konkretnym rozmiarze:

\begin{displaymath}
sasiedztwo_5 (P) = sasiedztwo (P, 5)
\end{displaymath}

\Defacto każdy operator opisywany w tej pracy może być parametryzowany. W kolejnych rozdziałach przyjęto konwencję według której definiując nowy operator zapisywana jest jego minimalna dziedzina, co nie oznacza, że podczas realizacji nie może on być parametryzowany. Analogicznie stwierdzenie, że operator powinien przyjmować daną liczbę argumentów nie oznacza, że nie może on przyjmować ich więcej. Innymi słowy sygnatura postaci:

\begin{displaymath}
operator: D \rightarrow C
\end{displaymath}

gdzie $D$ oznacza dziedzinę, a $C$ przeciwdziedzinę, jest równoważna z:

\begin{displaymath}
operator: D \times P \rightarrow C
\end{displaymath}

gdzie $P$ oznacza przestrzeń parametrów, zależnych od realizacji operatora.

Ponadto, w algorytmach znajdujących się w tej pracy używany jest operator $random(X)$ opisany sygnaturą \ref{signature:random}, zwracający losowy element zbioru $X$ (z rozkładem równomiernym).

\begin{signature}
	\caption{Operator $random(S)$ \label{signature:random}}
	\begin{align}
	random: &\withSize{A}{n} \rightarrow A \\
	X \gets &\left\{ x_0, x_1, \dots x_{n-1} \right\} \\
	\forall_{x_i, x_j \in X} P(random(X) = x_i) = &P(random(X) = x_j)
	\end{align}
	$A$ to dowolny zbiór, a $n$ jego rozmiar.
\end{signature}

\subsection{Osobnik, populacja i ocena} \label{subsection:specimen_and_foo}

Podstawowym pojęciem w dziedzinie algorytmów ewolucyjnych jest osobnik, czyli rozwiązanie. Definiujemy go jako element przestrzeni rozwiązań, którą również musimy zdefiniować. Na te pojęcia nie ma nałożonych żadnych ograniczeń, jednak od ich realizacji zależy łatwość realizacji i efektywność działania pozostałych pojęć, opisanych w dalszych podsekcjach.

Ważniejszym pojęciem jest funkcja oceny. 
Wbrew nazwie nie musi być to funkcja w rozumieniu matematycznym, a operator (patrz: rozdział \ref{subsection:operator})
\footnote{Stochastyczną funkcję oceny możemy zastosować na przykład w sytuacji, w której za pomocą algorytmu ewolucyjnego szukamy konfiguracji innej heurystyki. Osobnikiem w takiej sytuacji może być zestaw parametrów konfigurowanej heurystyki, a oceną - średnia jakość działania dla kilku uruchomień.}. 
Jego dziedziną powinna być przestrzeń możliwych osobników, a przeciwdziedziną dowolny zbiór na którym możemy określić relację porządku. 
Relacja ta odpowiada relacji bycia lepiej przystosowanym do środowiska w rzeczywistym procesie ewolucji.


\begin{signature}
	\caption{Osobnik \label{signature:specimen}}
	\begin{align}
	osobnik \in &\important{S}
	\end{align}
	Zbiór $\important{S}$ to przestrzeń rozwiązań.
\end{signature}

\begin{signature}
	\caption{Funkcja oceny \label{signature:eval}}
	\begin{align}
		\param{funkcjaOceny}: &\important{S} \rightarrow \important{E} \\
		\exists \minorityEvalRel \subset &\important{E} \times \important{E} \\
		\minoritySpecimenRel \gets &\left\{ (x, y): (\param{funkcjaOceny}(x), \param{funkcjaOceny}(y)) \in \minorityEvalRel \right\}
	\end{align}
	Zbiór $\important{E}$ to zbiór możliwych ocen osobnika, 
	a $\minorityEvalRel$ to relacja porządku na nim określona. Ponadto określamy relację lepszego dopasowania $\minoritySpecimenRel$, porządkującą przestrzeń osobników według porządku określonego na ich ocenach. 
\end{signature}

\subsection{Operator mutacji}

Dziedziną tego operatora jest przestrzeń rozwiązań, a przeciwdziedziną - klasa $\variable{m}$elementowych podzbiorów przestrzeni rozwiązań. Oznacza to, że jednokrotne zastosowanie operatora mutacji daje w wyniku $\variable{m}$ osobników powstałych przez modyfikację osobnika pierwotnego. Każdy ze zwróconych osobników powinien być nieznacznie różny od argumentu operatora. Zazwyczaj przyjmuje się $\variable{m} = 1$

Z operatorem mutacji ściśle związany jest jeden z parametrów algorytmu ewolucyjnego - prawdopodobieństwo mutacji. Jest to wartość określająca prawdopodobieństwo zastosowania operatora mutacji do osobnika w danym pokoleniu. Jeśli wartość ta jest równa 0, to operator mutacji nie jest w ogóle używany, a jeśli jest równa 1, to operator zostanie zastosowany do każdego osobnika.

\begin{signature}
	\caption{Operator mutacji \label{signature:mutation}}
	\begin{align}
	\param{opMutacji}: & \important{S} \rightarrow \withSize{\important{S}}{\variable{m}} \\
	\param{prawdMutacji} \in & \range{0}{1}
	\end{align}
	$\variable{m}$ to liczba zwracanych wyników mutacji.
\end{signature}	

\subsection{Operator krzyżowania} \label{subsection:crossover}

Dziedziną tego operatora jest klasa $\inputVar{c}$elementowych podzbiorów przestrzeni rozwiązań, a przeciwdziedziną - klasa $\outputVar{c}$elementowych pozdbiorów tej przestrzeni. Oznacza to, że operator ten przyjmuje $\inputVar{c}$ osobników (nazywanych \emph{rodzicami}) jako argument, a zwraca $\outputVar{c}$ osobników (nazywanych \emph{potomstwem}). Zazwyczaj przyjmuje się $ \inputVar{c} = 2 $ i $\outputVar{c} \in \left\{1, 2 \right\}$. Zwracane osobniki powinny być podobne (w takim sensie, że mają podobną reprezentację) do osobników wejściowych (argumentów operatora). 

Z operatorem krzyżowania ściśle związany jest jeden z parametrów algorytmu ewolucyjnego - prawdopodobieństwo krzyżowania. Jest to wartość określająca prawdopodobieństwo zastosowania operatora krzyżowania do osobnika w danym pokoleniu. Jeśli wartość ta jest równa 0, to operator krzyżowania nie jest w ogóle używany, a jeśli jest równa 1, to operator zostanie zastosowany do każdego osobnika.

\begin{signature}
	\caption{Operator krzyżowania \label{signature:crossover}}
	\begin{align}
	\param{opKrzyzowania}: & \withSize{\important{S}}{\inputVar{c}} \rightarrow \withSize{\important{S}}{\outputVar{c}} \\
	\param{prawdKrzyzowania} \in & \range{0}{1}
	\end{align}
	$\inputVar{c}$ to liczba rodziców, a $\outputVar{c}$ to liczba potomków.
\end{signature}	

\subsection{Operator selekcji} \label{subsection:natSel}

Zadaniem operatora selekcji jest symulacja zjawiska przeżycia silniejszych (czyli lepiej dopasowanych) osobników. Jest on stosowany pod koniec każdego pokolenia w celu usunięcia z niej osobników gorzej dopasowanych, poprzez wykorzystanie populacji wyjściowej jako używanej w kolejnym pokoleniu. Zmniejsza on różnorodność genetyczną w obrębie populacji, co w ogólności jest negatywnym efektem, ponieważ zahamowywuje proces eksplorację przestrzeni rozwiązań. Operator mutacji powinien eksplorować ją na tyle efektywnie, żeby operator selekcji odrzucał mało obiecujące kierunki eksploracji zamiast całkiem zatrzymywać jej proces.

Dziedziną tego operatora jest klasa $p$elementowych pozdbiorów przestrzeni rozwiązań, co oznacza, że przyjmuje on populację $p$ osobników. Wartość $p$ to ilość osobników w populacji pod koniec danej generacji, więc można ją przybliżać za pomocą równać z linii \ref{line:p_start}-\ref{line:p_stop} sygnatury \ref{signature:selection}, ponieważ w populacji znajdą się osobniki z populacji początkowej tego pokolenia oraz wyniki operatorów mutacji i krzyżowania. 

Przeciwdziedziną operatora selekcji jest $\param{rozmiarPopulacji}$krotny iloczyn kartezjański przestrzeni rozwiązań, co oznacza, że wynikiem działania operatora powinien być zbiór $\param{rozmiarPopulacji}$ osobników. Wartość $\param{rozmiarPopulacji}$ to parametr całej heurystyki, określająca jak liczna powinna być populacja na początku każdego pokolenia. Im większą wartość przyjmuje ten parametr, tym lepsze przeszukiwanie przestrzeni rozwiązań, ale też tym dłużej trwa sama heurystyka (ponieważ trzeba ewaluować więcej osobników i do większej liczby z nich zastosować operatory genetyczne). 

Dodatkowo na operator nakłada się wymóg opisany w liniach \ref{line:constraint_sel_start}-\ref{line:constraint_sel_stop} sygnatury \ref{signature:selection}. Mówią one o tym, że prawdopodobieństwo tego, że osobnik z populacji wejściowej znajdzie się w populacji wyjściowej powinno być tym większe im lepiej dopasowany jest osobnik. Ma to symulować zasadę przetrwania osobników najlepiej przystosowanych do środowiska.

\begin{signature}
	\caption{Operator selekcji \label{signature:selection}}
	\begin{align}
	\param{opSelekcji}: &\withSize{\important{S}}{p} \rightarrow \withSize{\important{S}}{\param{rozmiarPopulacji}} \\
	\param{rozmiarPopulacji} \in &\numberSet{N}_{+} \\
	\label{line:p_start} 
	p \approx &(1 + \param{prawdMutacji} \times \variable{m} \\
	          &+ \param{prawdKrzyzowania} \times \outputVar{c}) \\
	\label{line:p_stop} 
	&\times \param{rozmiarPopulacji} \\
	\label{line:constraint_sel_start}          
	T \gets &\left\{ t_0, t_1, \ldots t_{\param{rozmiarPopulacji}-1} \right\} \\
	s \in \param{opSelekcji}(T) &\Rightarrow s \in T\\
	P(i) \gets &P(t_i \in \param{opSelekcji}(T)) \\
	\label{line:constraint_sel_stop} 
	P(i) < P(j) &\Leftrightarrow (t_i, t_j) \in \minoritySpecimenRel
	\end{align}
\end{signature}

\subsection{Warunek stopu} \label{subsection:stop}

Warunek stopu, nazywany też warunkiem zatrzymania lub przerwania to pojęcie określające warunek zakończenia heurystyki. Jest to odpowiedź na pytanie ,,kiedy należy przestać przetwarzanie kolejnych pokoleń?''. Często stosuje się takie kryteria jak przekroczenie jakiejś arbitralnej liczby pokoleń, lub zaobserwowanie tzw. stagnacji. Zjawisko takie polega na znacznym zmniejszeniu różnorodności ocen w populacji, co oznacza, że znaleźliśmy optimum lokalne. Jeśli wariancja ocen przez kilka pokoleń się nie zmienia (lub zmienia, ale nie znacząco), to można uznać, że operatory genetyczne nie pozwolą na wyjście z tego optimum i przerwać działanie heurystyki. 
Warunek zatrzymania możemy traktować jako dodatkowy operator, jednak trudno jest określić jego jednoznaczną sygnaturę, ze względu na dowolność realizacji. W sygnaturze \ref{signature:stop} przedstawiono ogólny zapis operatora (z dowolną dziedziną, linia \ref{line:stop_general}) i sygnaturę jego przykładowej realizacji (opartej o stałą liczbę pokoleń, linie \ref{line:stop_maxGen_begin}-\ref{line:stop_maxGen_end}).

\begin{signature}
	\caption{Warunek zatrzymania i jego przykładowa realizacja \label{signature:stop}} 
	\begin{align}
		\label{line:stop_general}
		\param{warunekStopu}: &\ldots \rightarrow \left\{ 0, 1 \right\}
	\end{align}
	\begin{align}
		\label{line:stop_maxGen_begin}
		\param{warunekStopu}: &\numberSet{N} \rightarrow \left\{ 0, 1 \right\} \\
		\label{line:stop_maxGen_end}
		\param{warunekStopu}(g) = &1 \Leftrightarrow g \leq \overline{\variable{g}}
	\end{align}
	Zwrócenie wartości $1$ oznacza, że należy zakończyć działanie heurystyki, a $0$ - sytuację odwrotną. \\ 
	Wartość $g$ oznacza numer obecnego pokolenia (zaczynając od 1), a $\overline{\variable{g}}$ - maksymalną dopuszczalną liczbę pokoleń w ramach jednego przebiegu algorytmu ewolucyjnego.
\end{signature}	

\section{Szczegóły działania heurystyki} \label{section:ea_details}
 
Ogólny schemat działania algorytmu ewolucyjnego został przedstawiony w sekcji \ref{section:general_idea}. Kolejne kroki przedstawionego tam diagramu zostaną opisane ze szczegółami w kolejnych akapitach.

Cały proces rozpoczyna się od inicjalizacji populacji przy pomocy losowych osobników. Następnie, póki warunek zatrzymania nie jest spełniony, powtarzane jest kilka kroków wykonywanych w ramach jednego pokolenia. Są to kolejno: krzyżowanie, mutacja i selekcja naturalna.

\begin{algorithm}[h]
	\caption{Szczegółowy schemat działania kroku "Wykonaj krzyżowanie"	\label{algorithm:crossOver_std}}
	\begin{algorithmic}[1]
		\Context{
			$populacja$ 
			\Comment{Obecna populacja, tj. zbiór osobników}
			}
		\Params{
			$\param{prawdKrzyzowania}$
				\Comment{\raggedleft Prawdopodobieństwo krzyżowania}\\ 
			$\param{opKrzyzowania}$  
				\Comment{Operator krzyżowania}
			}
		\Start
		\Procedure{wykonajKrzyzowanie}{}
			\Var $noweOsobniki \gets \emptyset$
			\label{line:cross_init} 
			\ForAll {$osobnik \in populacja$}
			\label{line:cross_each} 
				\If {$random([0,1]) \leq \nicefrac{\param{prawdKrzyzowania}}{2}$}
				\label{line:cross_check} 
					\Var $partner \gets random(populacja \setminus \left\{ osobnik \right\})$ 
					\label{line:cross_choose}
					\Var $potomek \gets \param{opKrzyzowania}(\{ osobnik, partner \})$
					\label{line:cross_apply} 
					\State $noweOsobniki \gets noweOsobniki \cup \left\{ potomek \right\}$
					\label{line:cross_add}
				\EndIf 
			\EndFor
			\State $populacja \gets populacja \cup noweOsobniki$ 
			\label{line:cross_merge}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Algorytm \ref{algorithm:crossOver_std} opisuje szczegóły kroku "Wykonaj krzyżowanie". Krok ten rozpoczyna się od inicjalizacji zmiennej $noweOsobniki$ na pusty zbiór (w linii \ref{line:cross_init}), który w linii \ref{line:cross_merge}. zostanie dołączony do ogólnej populacji. Dla każdego osobnika w populacji (linia \ref{line:cross_each}) sprawdzane jest, czy należy wykonać krzyżowanie z jego udziałem (linia \ref{line:cross_check}). Jeżeli tak, to losowo dobierany jest jego partner (linia \ref{line:cross_choose}), a następnie na tak określonej parze osobników stosowany jest operator krzyżowania (linia \ref{line:cross_apply}), którego wynik jest dołączany do zbioru $noweOsobniki$ (linia \ref{line:cross_add}). Schemat ten przewiduje, że operator krzyżowania przyjmuje 2 osobniki jako argument (tzn. $\inputVar{c} = 2$, patrz: rozdział \ref{subsection:crossover}), przez co wartość, z którą porównujemy losowo wybraną liczbę z przedziału $\range{0}{1}$ to $\nicefrac{\param{prawdKrzyzowania}}{2}$. W ogólności, dla dowolnego $\inputVar{c}$ wartość ta wynosi $\nicefrac{\param{prawdKrzyzowania}}{\inputVar{c}}$, a zamiast jednego partnera należy wybrać ich $\inputVar{c}-1$.

\begin{algorithm}[h]
	\caption{Szczegółowy schemat działania kroku "Wykonaj mutację"	\label{algorithm:mutation_std}}
	\begin{algorithmic}[1]
		\Context{
			$populacja$ 
			\Comment{Obecna populacja, tj. zbiór osobników}
		}
		\Params{
			$\param{prawdMutacji}$
			\Comment{\raggedleft Prawdopodobieństwo mutacji}\\ 
			$\param{opMutacji}$  
			\Comment{Operator mutacji}
		}
		\Start
		\Procedure{wykonajMutacje}{}
		\Var $noweOsobniki \gets \emptyset$
		\label{line:mut_init}
		\ForAll {$osobnik \in populacja$}
		\label{line:mut_each}
			\If {$random([0,1]) \leq \param{prawdMutacji}$}
			\label{line:mut_check}
				\Var $mutant \gets \param{opMutacji}(osobnik)$
				\label{line:mut_apply}
				\State $noweOsobniki \gets noweOsobniki \cup \left\{ mutant \right\}$
				\label{line:mut_add}
			\EndIf 
		\EndFor
		\State $populacja \gets populacja \cup noweOsobniki$
		\label{line:mut_merge}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Algorytm \ref{algorithm:mutation_std} opisuje szczegóły kroku "Wykonaj mutację". Krok rozpoczyna się od inicjalizacji zmiennej $noweOsobniki$ na pusty zbiór (w linii \ref{line:mut_init}), który w linii \ref{line:mut_merge} zostanie dołączony do ogólnej populacji. Dla każdego osobnika w populacji (linia \ref{line:mut_each}) sprawdzane jest, czy należy wykonać na nim mutację (linia \ref{line:mut_check}), a jeśli tak, to stosowany jest do niego operator mutacji (linia \ref{line:mut_apply}), którego wynik zostaje dołączony do zbioru $noweOsobniki$ (linia \ref{line:mut_add}).

\begin{algorithm}[h]
	\caption{Szczegółowy schemat działania kroku "Dokonaj selekcji naturalnej"	\label{algorithm:natSel_std}}
	\begin{algorithmic}[1]
		\Context{
			$populacja$ 
			\Comment{Obecna populacja, tj. zbiór osobników}
		}
		\Params{
			$\param{rozmiarPopulacji}$
			\Comment{Rozmiar populacji}\\ 
			$\param{opSelekcji}$  
			\Comment{Operator selekcji}
		}
		\Start
		\Procedure{dokonajSelekcjiNaturalnej}{}
		\State $populacja \gets \param{opSelekcji}_{\param{rozmiarPopulacji}}(populacja)$
		\label{line:sel_apply}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Algorytm \ref{algorithm:natSel_std} opisuje szczegóły kroku "Dokonaj selekcji naturalnej", który \defacto sprowadza się do zastąpienia dotychczasowej populacji wynikiem zastosowania operatora selekcji na niej (linia \ref{line:sel_apply}).

\section{Analiza jakości działania}

Algorytmy ewolucyjne to rodzina losowych, iteracyjnych heurystyk populacyjnych. Określenie ,,losowych'' oznacza, że każde uruchomienie procesu optymalizacji może zwrócić inny wynik. Co za tym idzie, ocena działania heurystyki dla danego zestawu parametrów jest trudna i wymaga wielokrotnego zebrania wyników. W następnych podsekcjach opisane zostaną sposoby analizy jakości działania pojedynczego przebiegu heurystyki, jak i wielu przebiegów o tych samych parametrach.

\subsection{Analiza jednego przebiegu heurystyki}

Jak było wspomniane wyżej, algorytmy ewolucyjne to iteracyjne heurystyki populacyjne. Oznacza to, że w ramach jednego procesu optymalizacji wielokrotnie powtarzamy pewien krok (stąd określenie ,,iteracyjne'') w którym badamy wiele rozwiązań (stąd określenie ,,populacyjne'').

Aby ocenić pojedynczy przebieg, możemy analizować pewne statystyki oceny w skali populacji na przestrzeni wielu pokoleń.

Podstawowe statystyki używane w tym celu, to m.in.:
\begin{itemize}
	\item najlepsza i najgorsza ocena osobnika z populacji,
	\item średnia i odchylenie standardowe (lub wariancja \footnote{Często wariancji używa się do automatyzacji oceny, ponieważ obliczenie jej nie wymaga czasochłonnego pierwiastkowania. Znając wariancję w dowolnym momencie możemy obliczyć odchylenie standardowe, np. w celu prezentacji oceny.  \label{footer:variance}}) oceny osobników w populacji,
	\item mediana i kwantyle oceny osobników w populacji.
\end{itemize}

Wartości te można wygodnie zobrazować na wykresie pudełkowym, na osi odciętych umieszczając numery pokoleń, a na osi rzędnych - wartości odpowiednich statystyk. Takie zobrazowanie przebiegu heurystyki pozwala na wyciągnięcie wniosków i stosowne dopasowanie parametrów heurystyki (np. jeśli w problemie minimalizacji wszystkie wartości stopniowo maleją, to być może warto zwiększyć rozmiar populacji lub zmienić kryterium zatrzymania, aby cały proces trwał dłużej, ponieważ taka obserwacja wskazuje na efektywne działanie heurystyki).

W tej pracy do analizy wykorzystano tylko 4 z wyżej wymienionych statystyk: średnią, wariancję\footnote{Zdecydowano się na wykorzystanie wariancji zamiast odchylenia standardowego ponieważ wartości odchylenia okazały się być zbyt małe, aby były dostrzegalne na wykresach.}, minimum i maksimum. Są one w pełni wystarczające do analizy porównawczej między uruchomieniami. 

%\clearpage

\begin{figure}[H]
	\caption{Przykładowy wykres przebiegu \label{plot:random_example}}
	\centering
	\graph{random_example.tex}
\end{figure}

Na rysunku \ref{plot:random_example} przedstawiony jest przykładowy wykres statystyk populacji na przestrzeni wielu pokoleń. Wykresy takie, nazywane w skrócie \emph{wykresami przebiegów}, będą wykorzystywane w tej pracy do analizy pojedynczych uruchomień heurystyki. 

\begin{figure}[H]
	\caption{Wykres przebiegu, w którym globalne optimum nie znajduje się w ostatniej populacji \label{plot:mid_opt}}
	\centering
	\graph{mid_optimum.tex}
\end{figure}

Na rysunku \ref{plot:mid_opt} przedstawiony jest wykres przebiegu na którym możemy zaobserwować sytuację opisaną na końcu rozdziału \ref{section:general_idea}, tzn. taką, w której optimum globalne jest znalezione w innym pokoleniu niż ostatnie.

\begin{figure}[H]
	\caption{Wykres przebiegu w którym obserwujemy stagnację \label{plot:stagnation}}
	\centering
	\graph{stagnation.tex}
\end{figure}

Na rysunku \ref{plot:stagnation} przedstawiono sytuację, w której obserwujemy tzw. stagnację (wspominaną już w rozdziale \ref{subsection:stop}). Możemy zaobserwować, że od pewnego momentu (około sześćdziesiątej generacji) kolejne pokolenia nie przynoszą znaczącej zmiany wyniku, co mogłoby być powodem do przerwania działania heurystyki.

\subsection{Analiza wielu przebiegów heurystyki}

Jak zostało wspomniane na początku tej sekcji, algorytmy ewolucyjne to heurystyki losowe, przez co za każdym uruchomieniem zwracają różne wartości. Aby ocenić wyniki procesu optymalizacji dla różnych zestawów parametrów należy kilkukrotnie powtórzyć proces i porównywać statystyki wyników. Jeśli jesteśmy w trakcie dostrajania heurystyki (czyli dobierania najlepszych parametrów), to taką statystyką może być najlepszy wynik z kilku powtórzeń, jednak jeśli chcemy przeprowadzić miarodajne badania, to najprostszym podejściem dającym wgląd w jakość działania jest obliczenie średniej i wariancji (lub odchylenia standardowego, patrz: przypis \ref{footer:variance}) wyników wielu przebiegów dla różnych konfiguracji i porównanie ich testem statystycznym, takim jak np. test t-studenta.

\chapter{Przegląd literatury} \label{chapter:literature}

\chapter{Proponowane rozwiązania} \label{chapter:proposed}

Dotychczasowe implementacje algorytmów ewolucyjnych zazwyczaj (choć nie zawsze \cite{GGA}, \cite{SexualGA}) pomijały ważny aspekt procesu ewolucji, który w przyrodzie okazuje się mieć duży wpływ na dopasowywanie się gatunków do środowiska - podział gatunku na płcie. 
W rzeczywistości większa część istniejących gatunków, zaczynając od dość prostych (jak owady, czy rośliny), a kończąc na złożonych (takich jak ssaki), do rozmnażania potrzebują dwóch rodziców różniących się konkretnym chromosomem. 
Różnica ta jest powodem istnienia całego zespołu cech, które pozwalają podzielić osobniki na żeńskie i męskie, a w ogólności na osobniki różnych płci. 
Mimo, że nie jest to spotykane w naturze, to w ramach eksperymentu myślowego można założyć dowolną liczbę płci, a nie tylko dwie.

Przy opisywaniu operatorów wprowadzanych w tym rozdziale, używana będzie funkcja $plec(osobnik)$, przypisująca osobnikowi jego płeć.
Oznacza to, że przestrzeń rozwiązań musi zostać poszerzona o dodatkowy wymiar, jakim jest właśnie ta cecha.
Jedyne wymaganie nałożone na jej dziedzinę to to, żeby była skończonym, niepustym zbiorem.

\begin{signature}
	\caption{Funkcja $plec(osobnik)$ \label{signature:genderFoo}}
	\begin{align}
	plec: & \important{S} \rightarrow \important{G}
	\end{align}
\end{signature}

\begin{signature}
	\caption{Osobnik w kontekście DSEA \label{signature:specimen_dsea}}
	\begin{align}
	\important{S}_{DSEA} = &\important{S}_{EA} \times \important{G} \\
	\important{G} \neq & \emptyset \\
	|\important{G}| < &\infty
	\end{align}	
	$\important{G}$ to zbiór możliwych płci.\\
	W niniejszej pracy przyjęto istnienie co najwyżej 2 płci, ze zbiorem $\important{G}$ określonym jako $\important{G} = \{ \female, \male \}$
\end{signature}

\section{Heurystyka DSEA} \label{section:dsea}

Jak zostało pokazane w rozdziale \ref{chapter:literature}, istnieją rozwiązania które nie ignorują podziału populacji na płcie. 
Aby skutecznie je porównać i zaproponować nowe podejście, zdefiniowano schemat działania heurystki, opisany schematem blokowym znajdującym się na rysunku \ref{figure:dsea}. Ujmuje on wyżej opisany aspekt biologii organizmów w ramach nowego operatora selekcji. 
W dalszej części pracy tak zdefiniowaną heurystykę nazywać będziemy \textbf{algorytmem ewolucyjnym o podwójnej selekcji} (ang. \emph{double selection evolutionary algorithm}) i odnosić się do niej przy pomocy skrótu \textbf{DSEA}, będącego akronimem nazwy angielskiej.

\subsection{Działanie} \label{subsection:dsea_scheme}

Na rysunku \ref{figure:dsea} przedstawiono schemat działania heurystyki DSEA w postaci schematu blokowego. 

\begin{figure}[H]
	\caption{Schemat działania heurystyki DSEA \label{figure:dsea}}
	\img{dsea.png}
\end{figure}

W większej części diagram zgadza się z diagramem \ref{figure:ea_general} przedstawionym w sekcji \ref{section:general_idea}. 
Istotne różnice między diagramami to zmiana działania kroku "Wykonaj krzyżowanie oraz dodanie nowego kroku "Zadbaj o różnorodność populacji" zaraz przed nim. 
Zostały one zdefiniowane w paragrafach kolejno \ref{subsubsection:my_crossover} i  i \ref{figure:fixing}. 
Ponadto, zmieniła się nazwa operatora używanego w kroku "Dokonaj selekcji naturalnej", co zostanie opisane w podsekcji \ref{subsection:new_natSel}.

\subsubsection{Krok ,,Wykonaj krzyżowanie''} \label{subsubsection:my_crossover}


Na rysunku \ref{figure:my_crossover} znajduje się diagram przedstawiający krok "Wykonaj krzyżowanie" jako sekwencję mniejszych kroków. Za pomocą operatora selekcji płciowej\footnote{
	W podsekcji \ref{subsection:new_genSel} opisane zostanie znaczenie i sygnatura tego operatora, wyjaśnione jest uproszczenie polegające na zwracaniu par rodziców oraz różnica w interpretacji parametru $\param{prawdKrzyzowania}$. 
} generowana jest lista par rodziców. 
Następnie, dla każdej z nich wykonuje się krzyżowanie, traktując oba osobniki z pary jako argumenty operatora krzyżowania, a jego wynik dołączając do populacji. 
W przeciwieństwie do realizacji opisanej w sekcji \ref{section:ea_details} przy pomocy algorytmu \ref{algorithm:crossOver_std} wyniki operatora krzyżowania nie są dołączane do osobnego zbioru, a od razu do całości populacji. 
Dzieje się tak, ponieważ zadanie wyboru rodziców jest oddelegowane do operatora, który zawsze zostanie użyty przed operatorem krzyżowania.

\begin{figure}[h]
	\caption{Szczegóły działania kroku ,,Wykonaj krzyżowanie'' \label{figure:my_crossover}}
	\img{my_crossover.png}
\end{figure}

\subsubsection{Krok ,,Zadbaj o różnorodność populacji''} \label{subsubsection:fixing}

Wprowadzenie podziału populacji na płcie powinno skutkować odmiennym traktowaniem osobników w zależności od tej cechy. 
Co za tym idzie, obie podgrupy powinny różnić się tym bardziej, im więcej generacji zostało przeprowadzonych.
Efekt taki ma zarówno wady, jak i zalety. 
Dzięki niemu potomstwo (czyli wynik operatora krzyżowania) w danej populacji powinno również zachować większą różnorodność. 
Negatywną stroną tego zjawiska jest fakt, że operator selekcji naturalnej, który nie powinien brać pod uwagę płci, może zaburzyć stosunek liczności osobników danych płci względem siebie. 
W skrajnych sytuacjach może dojść do tego, że w całej populacji zabraknie osobników którejś z płci, co uniemożliwi dalsze działanie heurystyki (ponieważ niemożliwe byłoby zastosowanie operatora krzyżowania). 
Ponadto, im dysproporcje między różnymi płciami będą większe, tym mniejsza będzie różnorodność całej populacji, co szybko prowadzi do stagnacji.

\begin{figure}[H]
	\caption{Szczegóły działania kroku ,,Zadbaj o różnorodność populacji'' \label{figure:fixing}}
	\img{fixing.png}
\end{figure}

Na rysunku \ref{figure:fixing} przedstawiono krok mający ograniczyć negatywne efekty podziału na płcie, opisane wyżej. 

W pierwszej jego części do populacji dodajemy tzw. ,,domieszki'' (ang. \emph{mixins}), czyli losowe osobniki (tworzone w ten sam sposób co populacja początkowa). 
Ma to na celu regularne uzupełnianie puli genów obecnych w populacji, na wypadek gdyby geny odpowiedzialne za pozytywną cechę zanikły z powodu losowości operatora selekcji naturalnej lub płciowej. 
Ilość domieszek jest kontrolowana przez współczynnik domieszek ($\param{wspDomieszek}$), będący stosunkiem pożądanej ilości nowych osobników do wartości $\param{rozmiarPopulacji}$.

Druga część kroku ma zapobiec sytuacjom, w których któraś płeć nie występuje w populacji, lub jest zbyt słabo reprezentowana. 
Jeśli liczność którejś z płci w populacji spadnie poniżej arbitralnie dobranej liczby $\param{d}$, to do populacji dołączane jest $\lceil \param{wspSamorodków} \times \param{rozmiarPopulacji} \rceil$ (lub $d$, jeśli $d$ jest większe) losowych osobników tej płci\footnote{
	Alternatywnym rozwiązaniem mogłaby być zmiana płci losowych osobników pozostałych płci.
}. 
W praktyce, w ramach tej pracy użyto arbitralnie dobranych wartości $\param{d} = 5$ i $\param{wspSamorodków} = 0.05$.

\subsection{Operator selekcji naturalnej} \label{subsection:new_natSel}

Heurystyka DSEA, jak nazwa wskazuje, korzysta z dwóch operatorów selekcji, które należy rózróżnić. 
Z tego powodu dotychczasowy operator selekcji zmienił nazwę na \textbf{operator selekcji naturalnej}. 
Zachowuje on to samo znaczenie i zastosowanie, opisane w rozdziale \ref{subsection:natSel}. 

Dodatkowo, wymaga się, aby prawdopodobieństwo znalezienia się osobnika w zbiorze zwracanym przez ten operator było niezależne od płci osobnika. 
Zostało to zapisane w linii \ref{line:gender_resistant} sygnatury \ref{signature:natSel}, korzystając z twierdzenia zgodnie z którym prawdopodobieństwo łączne dwóch zdarzeń jest równe iloczynowi ich prawdopodobieństw wtedy i tylko wtedy, gdy są to zdarzenia niezależne.

\begin{signature}
	\caption{Operator selekcji naturalnej \label{signature:natSel}}
	\begin{align}
	\param{opSelNat}: &\withSize{\important{S}}{p} \rightarrow \withSize{\important{S}}{\param{rozmiarPopulacji}} \\
	\param{rozmiarPopulacji} \in &\numberSet{N}_{+} \\
	p \approx &(1 + \param{prawdMutacji} \times \variable{m} \\
	&+ \param{prawdKrzyzowania} \times \outputVar{c}) \\
	&\times \param{rozmiarPopulacji} \\
	T \gets &\left\{ t_0, t_1, \ldots t_{\param{rozmiarPopulacji}-1} \right\} \\
	s \in \param{opSelNat}(T) &\Leftrightarrow \exists_{t \in T}  t \equiv s \\
	P(i) \gets &P(t_i \in \param{opSelNat}(T)) \\
	\forall_{i \in \range{0}{\param{rozmiarPopulacji}-1}}P(i) < P(j) &\Leftrightarrow (t_i, t_j) \in \minoritySpecimenRel \\
	\label{line:gender_resistant}
	\forall_{i \in \range{0}{\param{rozmiarPopulacji}-1}, g \in \important{G}}P(i \wedge & plec(t) = g) = P(i) \times P(plec(t_i) = g)
	\end{align}
\end{signature}

Standardowo korzysta się z operatorów selekcji naturalnej które odpowiednią ilość razy powtarzają wybór pojedynczego osobnika (bez powtórzeń) z populacji wejściowej, zbierając w ten sposób populację wyjściową. 
O ile sam sposób wyboru różni się między realizacjami operatora, to kolejne osobniki dołączane do populacji wyjściowej są zazwyczaj wybierane przy pomocy tego samego podejścia, które dalej będzie nazywane operatorem wyboru.
Został on zdefiniowany w sygnaturze \ref{signature:chooseOp}.
Rzecz jasna istnieją realizacje, które korzystają z wielu operatorów wyboru, ale nie są one tematem tej pracy i nie będą w niej poruszane.

\begin{signature}
	\caption{Operator wyboru \label{signature:chooseOp}}
	\begin{align}
		\param{opWyboru}: &\withSize{\important{S}}{p} \rightarrow \important{S}
	\end{align}
\end{signature}

Realizacje operatorów wyboru nazywamy zgodnie z nazwami operatorów selekcji które z nich korzystają.
Przykładowo, turniejowy operator selekcji korzysta z turniejowego operatora wyboru.
Operatory wykorzystane w tej pracy zostały opisane w \todo{odnieść się do eksperymentów}.

Warto zauważyć, że wcześniej zdefiniowany (sygnatura \ref{signature:random} w rozdziale \ref{chapter:eaDesc}) operator $random(X)$ może być traktowany jako operator wyboru.
Nie nadaje się on do zastosowań mających na celu poprawę wyników heurystyki, jednak korzystając z niego możemy opisać istniejące podejścia w modelu DSEA (patrz: podsekcja \ref{subsection:literatureRealization}).

Wydzielenie abstrakcji wyboru jednego rozwiązania pozwala na zapisanie uogólnionego schematu działania większości popularnie stosowanych operatorów selekcji.
Jest on opisany w algorytmie \ref{algorithm:natSel_choose}.

\begin{algorithm}[h]
	\caption{Schemat działania operatora selekcji naturalnej korzystającego z operatora wyboru \label{algorithm:natSel_choose}}
	\begin{algorithmic}[1]
		\Input{
			$populacja$ \Comment{Populacja wyjściowa}
			}
		\Output{
			$wynik$ \Comment{Populacja wyjściowa}
			}
		\Start
		\Params{
			$\param{rozmiarPopulacji}$ \Comment{Rozmiar populacji} \\
			$\param{opWyboru}$ \Comment{Operator wyboru}\\
			}
		\Operator{$\param{opSelNat}$}{$populacja$}
			\Var $wynik \gets \emptyset$ 
			\label{line:natSelChoose_init}
			\While{$|wynik| < \param{rozmiarPopulacji}$}
			\label{line:natSelChoose_while}
				\State $wynik \gets wynik \cup \{ \param{opWyboru}(populacja \setminus wynik) \}$
				\label{line:natSelChoose_choose}
			\EndWhile
			\State \Return{$wynik$}
			\label{line:natSelChoose_return}
		\EndOperator
	\end{algorithmic}
\end{algorithm}

Działanie takiego operatora zaczyna się od inicjalizacji zmiennej $wynik$, zwracanej jako rezultat (linia \ref{line:natSelChoose_return}). 
Początkowa jej wartość to zbiór pusty (linia \ref{line:natSelChoose_init}), jednak w kolejnym kroku rozpoczyna się pętla, powtarzana tak długo, aż zbiór ten będzie miał odpowiedni rozmiar (linia \ref{line:natSelChoose_while}).
W ciele tej pętli za pomocą operatora wyboru $\param{opWyboru}$ dokonuje się selekcji jednego nie wybranego jeszcze rozwiązania i dołącza sie je do zbioru $wynik$ (linia \ref{line:natSelChoose_choose}).

\subsection{Operator selekcji płciowej} \label{subsection:new_genSel}

W przeciwieństwie do tego jak działają klasyczne algorytmy ewolucyjne, w przyrodzie fakt dobierania się osobników w pary w celu wydania potomstwa nie jest losowy.
W zależności od gatunku i sytuacji środowiskowej przedstawiciele jednej lub obu płci muszą przekonać swoich przyszłych partnerów o tym, że mają cechy, które przekazane potomstwu dałyby mu większą szansę na przetrwanie.
Sposoby na to są różne - samce różnych gatunków rywalizują o samice poprzez walkę, okrzyki i śpiew, taniec, itd. 
U innych gatunków to samice zabiegają o względy partnerów.
Ponadto, różne gatunki stosują różne strategie wiązania się w pary.
Niektóre z nich starają się krzyżować tak często jak to możliwe z możliwie dużą liczbą partnerów, co powoduje dużą liczbę potomstwa, z których ,,odsiewana'' jest słabo przystosowana do środowiska większość.
Inne wiążą się w pary na całe życie (jak np. niektóre gatunki ptaków), albo przynajmniej na jakiś czas, dłuższy niż jedno pokolenie.

Operator selekcji płciowej to nowy element schematu heurystyki, który ma symulować te zjawiska i strategie.
W ogólności osobniki lepiej dopasowane do środowiska powinny mieć większą szansę na zostanie rodzicami niż te dopasowane gorzej.
Zastosowanie tego operatora do populacji z poprzedniego pokolenia powinno zwrócić zestaw par osobników-rodziców, z których każda para zostanie dalej przekazana do operatora krzyżowania.

W naturze, podobnie jak w podejściach porównywanych w tej pracy, rodziców jest dwoje. 
W sztucznym środowisku symulacyjnym liczba ta może być w gruncie rzeczy dowolna. 
Oznacza to, że wspomniane wyżej pary rodziców mogą być zbiorami o dowolnym rozmiarze.

Dotychczasowe algorytmy ewolucyjne można traktować jako DSEA z losowym operatorem selekcji płciowej.

Zmienia się znaczenie prawdopodobieństwa krzyżowania. 
Nazwa tego parametru zostaje bez zmian, aby nie komplikować nazewnictwa, jednak sama wartość nie przekłada się na matematyczne prawdopodobieństwo tego, że losowy osobnik zostanie rodzicem. 
Zamiast tego może być rozumiana jako stosunek liczby zdarzeń krzyżowania w każdym pokoleniu do rozmiaru populacji. 
Jest to ściśle związane z liczbą potomków tworzonych w jednej generacji, jednak przez to, że krzyżowanie może skutkować utworzeniem więcej niż jednego potomka, nie należy rozumieć tego parametru jako stosunku liczby krzyżówek do rozmiaru populacji.

\begin{signature}
	\caption{Operator selekcji płciowej \label{signature:genSel}}
	\begin{align}
		\param{opSelPlciowej}: &\withSize{ \important{S}}{\param{rozmiarPopulacji} } \rightarrow \withSize{ ( \withSize{\important{S}  }{\inputVar{c}} ) }{q} \\
		q = & \lceil \param{prawdKrzyzowania} \times \param{rozmiarPopulacji} \rceil \\
		T \gets &\left\{ t_0, t_1, \ldots t_{\param{rozmiarPopulacji}-1} \right\} \\
		\exists_{P \in \param{opSelekcji}(T)} t \in P &\Rightarrow t \in T
	\end{align}	
	$\inputVar{c}$ to ilość osobników potrzebna do wykonania krzyżowania (patrz: sygnatura \ref{signature:crossover}, rozdział \ref{subsection:crossover}). \\
	Operator zwraca zbiór $q$ zbiorów, z których każdy zawiera $\inputVar{c}$ osobników.
\end{signature}

\subsection{Realizacja wybranych operatorów selekcji płciowej} \label{subsection:literatureRealization}

W rozdziale \ref{chapter:literature} przedstawiono przegląd prac naukowych o tematyce zgodnej z tematem tej pracy, tj. z uwzględnianiem zjawiska płci w algorytmach ewolucyjnych.
Spośród przedstawionych tam pozycji wybrano dwie, które prezentowały nieco odmienne podejścia do zagadnienia: GGA \cite{GGA}, które opierało się o wymuszenie różnych płci rodziców, wybierając ich losowo, oraz SexualGA \cite{SexualGA}, w którym nie wprowadzano rozróżnienia osobników na płcie, ale każdego z rodziców wybierano w inny sposób, tj. za pomocą innego operatora wyboru.

Oba te podejścia można opisać przy pomocy tego samego schematu, jednak odmiennie parametryzowanego dla każdej z tych metod. Algorytm \ref{algorithm:common_genSel} opisuje jego działanie.

\begin{algorithm}
	\caption{Schemat działania wybranych operatorów selekcji płciowej \label{algorithm:common_genSel} }
	\begin{algorithmic}[1]
		\Input{
			$populacja$ \Comment{Populacja wyjściowa}
		}
		\Output{
			$rodzice$ \Comment{Zbiór par rodziców}
		}
		\Params{
			$\param{opWyboru1}$ \Comment{Operator wyboru pierwszego z rodziców} \\
			$\param{opWyboru2}$ \Comment{Operator wyboru drugiego z rodziców} \\
			$\param{plecMaZnaczenie}$ \Comment{\raggedleft Wartość logiczna określająca, czy rodzice muszą różnić się płcią}\\
			$\param{prawdKrzyzowania}$ \Comment{Prawdopodobieństwo krzyżowania} \\
			$\param{rozmiarPopulacji}$ \Comment{Ilość osobników na początku pokolenia}
		}
		\Start
		\Operator{$\param{opSelPlciowej}$}{$populacja$}
		\Var $rodzice \gets \emptyset$
		\label{line:stdGenSelChoose_init_parent}
		\Var $kandydaci1 \gets \begin{cases} 
			\left\{ s: plec(s)=\female, s \in populacja \right\} &: \param{plecMaZnaczenie}=\top\\ 
			populacja &: \param{plecMaZnaczenie}=\bot
		\end{cases} $
		\label{line:stdGenSelChoose_init_candidates_begin}
		\Var $kandydaci2 \gets \begin{cases} 
			\left\{ s: plec(s)=\male, s \in populacja \right\} &: \param{plecMaZnaczenie}=\top\\ 
			populacja &: \param{plecMaZnaczenie}=\bot
		\end{cases} $
		\label{line:stdGenSelChoose_init_candidates_end}
		\While{$|rodzice| < \param{rozmiarPopulacji}\times\param{prawdKrzyzowania}$}
		\label{line:stdGenSelChoose_while}
			\Var $rodzic1 \gets opWyboru1(kandydaci1) $
			\label{line:stdGenSelChoose_choose_begin}
			\Var $rodzic2 \gets opWyboru2(kandydaci1 \setminus \left\{ rodzic1 \right\}) $
			\label{line:stdGenSelChoose_choose_end}
			\State $rodzice \gets rodzice \cup \{  \{ rodzic1, rodzic2 \} \}$
			\label{line:stdGenSelChoose_parents_merge}
		\EndWhile
		\State \Return{$rodzice$}
		\label{line:stdGenSelChoose_return}
		\EndOperator
	\end{algorithmic}
	Symbole $\top$ i $\bot$ oznaczają kolejno prawdę i fałsz.
\end{algorithm}

Działanie operatora rozpoczyna się od deklaracji i inicjalizacji zmiennych pomocniczych.
Zbiór $rodzice$ początkowo jest pusty (linia \ref{line:stdGenSelChoose_init_parent}).
Dodatkowo, deklarujemy dwa zbiory przechowujące kandydatów na każdego z rodziców (linie \ref{line:stdGenSelChoose_init_candidates_begin}-\ref{line:stdGenSelChoose_init_candidates_end}).
W zależności od parametru $\param{plecMaZnaczenie}$ przechowują one albo całą populację (jeżeli $\param{plecMaZnaczenie} = \bot$, czyli rodzice mogą być tej samej płci), albo odflitrowane osobniki odpowiedniej płci (jeżeli $\param{plecMaZnaczenie} = \top$, czyli wymagane jest, aby rodzice byli różnych płci).

Następnie, póki nie zostanie wybrana odpowiednia liczba par rodziców (linia \ref{line:stdGenSelChoose_while}) powtarzany jest zestaw operacji określający kolejną z nich.
Za pomocą operatora $\param{opWyboru1}$ ze zbioru $\param{kandydaci1}$ wybierany jest pierwszy rodzic (linia \ref{line:stdGenSelChoose_choose_begin}).
Drugi z rodziców jest wybierany ze zbioru $\param{kandydaci2}$ za pomocą operatora $\param{opWyboru2}$  (linia \ref{line:stdGenSelChoose_choose_end}), nie dopuszczając do sytuacji w której oboje rodziców byłoby tym samym osobnikiem (mogłoby się tak zdarzyć, jeżeli $\param{plecMaZnaczenie} = \bot$, więc oboje z nich byłoby wybieranych z całej populacji).
Dwuelementowy zbiór tak wybranych rodziców jest dołączany do zbioru $rodzice$.

Kiedy określimy odpowiednio dużo par, zmienna $rodzice$ jest zwracana jako wynik operatora (linia \ref{line:stdGenSelChoose_return}).

Tak określona realizacja powiela założenie tej pracy, zgodnie z którym płci jest co najwyżej 2 ($|\important{G}| \in \{ 1, 2 \}$; jeżeli $\param{plecMaZnaczenie} = \bot$ to liczność tego zbioru nie ma znaczenia, ponieważ funkcja $plec(s)$ nie jest używana, w jednak w przeciwnej sytuacji musi ona wynosić 2), dodatkowo zakładając liczbę rodziców wymaganą przez operator krzyżowania $\inputVar{c}=2$.
Algorytm można dość łatwo uogólnić do postaci, w której liczby te są większe, pamiętając, że jeżeli $\param{plecMaZnaczenie} = \top$, to rodzice muszą być różnych płci, więc rozmiar argumentu operatora krzyżowania musi być równy ich liczbie ($\inputVar{c} = |\important{G}|$).

\subsubsection{Standardowe algorytmy ewolucyjne}

Jeżeli:
\begin{itemize}
	\item użyto operatora selekcji płciowej opisanego powyżej, sparametryzowanego przy pomocy:
	\begin{itemize}
		\item $\param{plecMaZnaczenie} = \bot$,
		\item $\param{opWyboru1} = random$,
		\item $\param{opWyboru2} = random$,
	\end{itemize}
	\item użyto wybranego operatora selekcji naturalnej ($\param{opSelNat} \neq random$),
	\item zignorowano liczbę płci ($|\important{G}| \in \numberSet{N}_{+}$) , ponieważ $\param{plecMaZnaczenie} = \bot$,
\end{itemize}
to DSEA sprowadza się do standardowego algorytmu ewolucyjnego, w którym na prawdopodobieństwo wydania potomstwa ma wpływ jedynie operator selekcji naturalnej.

\subsubsection{GGA}

GGA \cite{GGA} to wariacja na temat algorytmu genetycznego (co oznacza, że jej autorzy wykorzystywali reprezentację osobnika przez wektor bitów), w której wyróżnia się cechę osobnika określającej jego płeć i wymaga, aby rodzice różnili się nią. Każdy z rodziców jest wybierany losowo. Można to zrealizować spełniając następujące warunki:
\begin{itemize}
	\item użyto operatora selekcji płciowej opisanego powyżej, sparametryzowanego przy pomocy:
	\begin{itemize}
		\item $\param{plecMaZnaczenie} = \top$,
		\item $\param{opWyboru1} = random$,
		\item $\param{opWyboru2} = random$,
	\end{itemize}
	\item użyto wybranego operatora selekcji naturalnej ($\param{opSelNat} \neq random$),
	\item liczba płci jest większa niż 1($|\important{G}| > 1$).
\end{itemize}

\subsubsection{SexualGA}

SexualGA \cite{SexualGA} to kolejna wariacja na temat algorytmu genetycznego. Autorzy nie wyróżniali w niej cechy określającej płeć osobnika, proponując inne podejście do zjawiska płci. Przedstawione rozwiązanie wykorzystywało operator selekcji do wybrania rodziców, a nie osobników przechodzących do kolejnego pokolenia, a każdy z nich był wybierany za pomocą innego operatora wyboru\footnote{
	W oryginalnej pracy nie używano określenia ,,operator wyboru'', a ,,operator selekcji''.
}. Miało to symulować różne zachowania samców i samic związane z wyborem partnera.

Jeżeli poniższe warunki będą spełnione, to DSEA sprowadza się do SexualGA:
\begin{itemize}
	\item użyto operatora selekcji płciowej opisanego powyżej, sparametryzowanego przy pomocy:
	\begin{itemize}
		\item $\param{plecMaZnaczenie} = \bot$,
		\item $\param{opWyboru1} \neq random \vee \param{opWyboru2} \neq random$,
	\end{itemize}
	\item użyto losowego operatora selekcji naturalnej ($\param{opSelNat} = random$),
	\item zignorowano liczbę płci ($|\important{G}| \in \numberSet{N}_{+}$) , ponieważ $\param{plecMaZnaczenie} = \bot$).
\end{itemize}

Podany wyżej warunek, mówiący o tym, że co najmniej jeden operator wyboru musi być różny od losowego ($random$) wynika z tego, że gdyby oba operatory działały losowo, to heurystyka polegałaby na kompletnie losowym przeszukiwaniu przestrzeni rozwiązań.
Według autorów najlepsze wyniki osiągano używając operatora losowego w połączeniu z jakimś nie będącym losowym, jednak sytuacja w której użyto tego samego operatora dla obu płci jest warta zbadania.

\section{Proponowany operator selekcji płciowej}

U wielu gatunków występujących w przyrodzie (np. u większości płetwonogich, w tym morsów i fok \cite{pletwonogiMajaHaremy}) występuje zjawisko formowania się haremów.
Polega ono na tym, że tylko mała liczba osobników jednej z płci (zazwyczaj samców\footnote{
	Mimo, że nie zawsze osobniki alfa są płci męskiej, to w dalszej części opisu będziemy zakładać, że tak właśnie jest, mimo, że to uproszczenie.
}, nazywanych dalej \emph{osobnikami alfa}) przyczynia się do wydania na świat potomstwa.
Oznacza to, że dostęp do grupy samic (nazywanej \emph{haremem}) ma bardzo ograniczona grupa jednostek.
Dzieje się tak, ponieważ osobniki alfa są w ogólności silniejsze od pozostałych i bronią dostępu do samic przed resztą samców.
Zakaz ten nie zawsze jest przestrzegany.
W momencie, w którym osobniki alfa są czymś zajęte, pewien odsetek osobników tej samej płci ma szansę na rozmnożenie się.
Osobniki którym się to uda nazywane są \emph{osobnikami beta}.

Mimo, że takie zjawisko w dużym stopniu ogranicza różnorodność genetyczną, to w naturze wydaje się przynosić pozytywne rezultaty.
Z tego powodu zdecydowano się zbadać haremowe podejście do dobierania się w pary w celu rozmnażania.
Zrealizowano to definiując realizację operatora selekcji płciowej, nazywaną operatorem haremowym, opisaną w algorytmie \ref{algorithm:harem}. Wymaga ona, aby w populacji występowały dokładnie 2 płcie ($|\important{G}| = 2$).

\begin{algorithm}
	\caption{Schemat działania operatora haremowego \label{algorithm:harem}}
	\begin{algorithmic}[1]
		\Input{
			$populacja$ \Comment{Populacja wyjściowa}
		}
		\Output{
			$rodzice$ \Comment{Zbiór par rodziców}
		}
		\Params{
			$\param{liczbaAlfa}$ \Comment{Liczba osobników alfa} \\
			$\param{wspBeta}$ \Comment{Stosunek liczby par rodziców zawierających osobnika alfa do liczby wszystkich par} \\
			$\param{opWyboruAlfa}$ \Comment{Operator wyboru osobników alfa} \\
			$\param{opWyboruBeta}$ \Comment{Operator wyboru osobników beta} \\
			$\param{opWyboruPartnerow}$ \Comment{\raggedleft Operator wyboru partnerów przeciwnej płci} \\
			$\param{prawdKrzyzowania}$ \Comment{Prawdopodobieństwo krzyżowania} \\
			$\param{rozmiarPopulacji}$ \Comment{Ilość osobników na początku pokolenia}
		}
		\Start
		\Operator{opHaremowy}{$populacja$}
		\Var $rodzice \gets \emptyset$
		\label{line:harem_init_parents}
		\Var $kandydaci1 \gets \left\{ s: plec(s)=\male, s \in populacja \right\} $ 	
		\label{line:harem_init_candidates_begin}
		\Var $kandydaci2 \gets \left\{ s: plec(s)=\female, s \in populacja \right\} $
		\label{line:harem_init_candidates_end}
		\Var $liczbaZbiorowRodzicow \gets \lceil \param{prawdKrzyzowania} \times \param{rozmiarPopulacji} \rceil$
		\label{line:harem_init_out_size}
		\Var $liczbaBeta \gets \lceil \param{wspBeta} \times liczbaZbiorowRodzicow \rceil$
		\label{line:harem_init_beta_count}
		\Var $perAlfa \gets \lceil (liczbaZbiorowRodzicow-liczbaBeta)/\param{liczbaAlfa } \rceil$
		\label{line:harem_init_per_alfa}
		\For {$i \gets 1 \To \param{liczbaAfa}$}
		\label{line:harem_alfa_main_loop}
			\Var $alfa \gets \param{opWyboruAlfa}(kandydaci1)$
			\label{line:harem_choose_alfa}
			\State $kandydaci1 \gets kandydaci1 \setminus \left\{ alfa \right\}$
			\label{line:harem_alfa_remove_alfa}
			\For {$j \gets 1 \To perAlfa$}
			\label{line:harem_alfa_partner_loop}
				\Var $partner \gets \param{opWyboruPartnerów}(kandydaci2)$
				\label{line:harem_alfa_partner_choose}
				\State $zbioryRodzicow \gets zbioryRodzicow \cup \{ \{ alfa, partner \} \}$
				\label{line:harem_alfa_add}
			\EndFor
		\EndFor
		\For {$i \gets 1 \To liczbaBeta$}
		\label{line:harem_beta_loop}
			\Var $beta \gets \param{opWyboruBeta}(kandydaci1)$
			\label{line:harem_beta_choose}
			\Var $partner \gets \param{opWyboruPartnerow}(kandydaci2)$
			\label{line:harem_beta_partner}
			\State $rodzice \gets rodzice \cup \{ \{ beta, partner \} \}$
			\label{line:harem_beta_add}
		\EndFor
		\State \Return $rodzice$
		\label{line:harem_return}
		\EndOperator
	\end{algorithmic}
\end{algorithm}

Działanie takiego operatora zależy od pięciu parametrów, poza parametrami samej heurystyki.
Są to trzy operatory wyboru: $\param{opWyboruAlfa}$ służącego do wyboru osobników alfa, $\param{opWyboruBeta}$ służącego do wyboru osobników beta oraz $\param{opWyboruPartnerów}$ wykorzystywanego do wyboru partnerów dla osobników alfa i beta.
Ponadto, wykorzystywane są dwa parametry liczbowe: $\param{liczbaAlfa}$ określający liczbę osobników alfa wybieranych w pojedynczym pokoleniu i $\param{wspBeta}$, czyli współczynnik określający stosunek liczby par rodziców z których jeden jest osobnikiem alfa do liczby wszystkich par rodziców 

Działanie operatora zaczyna się od inicjalizacji zmiennej $rodzice$ na pusty zbiór (linia \ref{line:harem_init_parents}) oraz rozdzielenia populacji na zbiory $kandydaci1$ i $kandydaci2$, zawierające osobniki różnych płci (linie \ref{line:harem_init_candidates_begin} - \ref{line:harem_init_candidates_end}).
Następnie obliczane są wartości $liczbaZbiorowRodzicow$, czyli całkowita liczba par rodziców zwracanych przez operator  (linia \ref{line:harem_init_out_size}), $liczbaBeta$, czyli liczba osobników beta biorących udział w rozmnażaniu  (linia \ref{line:harem_init_beta_count}), oraz $perAlfa$, czyli liczba par rodziców przypadających na jednego osobnika alfa (linia \ref{line:harem_init_per_alfa}).

Kolejnym krokiem jest wygenerowanie par rodziców zawierających osobnika alfa.
$\param{liczbaAfa}$ razy powtarzane jest (w pętli w linii \ref{line:harem_alfa_main_loop}) wybranie kolejnego takiego osobnika $alfa$ (w linii \ref{line:harem_choose_alfa}) i usunięcie go ze zbioru kandydatów danej płci (w linii \ref{line:harem_remove_alfa}).
Dzięki temu żaden osobnik alfa nie zostanie wybrany dwukrotnie, ani nie pokryje się z którymś z osobników beta.
Dla danego osobnika alfa wybierany jest $perAlfa$ (w pętli w linii \ref{line:harem_alfa_partner_loop}) partnerów $partner$ (linia \ref{line:harem_alfa_partner_choose}), a tak określone pary rodziców są dołączane do zbioru $rodzice$ (w linii \ref{line:harem_alfa_add}).

W dalszej kolejności wybierane jest $liczbaBeta$ osobników beta (linie \ref{line:harem_beta_loop}-\ref{line:harem_beta_choose}), dla których dobierani są partnerzy $partner$ (w linii \ref{line:harem_beta_partner}). Tak wybrane pary również dołączane są do zbioru $rodzice$ (linia \ref{line:harem_beta_add}).

Operator zwraca zmienną $rodzice$ (w linii \ref{line:harem_return}).

Przedstawiony schemat nie zgadza się z sygnaturą operatora selekcji płciowej (sygnaturą \ref{signature:genSel}) przedstawioną w podsekcji \ref{subsection:new_genSel}, ponieważ w niektórych sytuacjach zwraca więcej par rodziców niż powinien. 

Oczekiwany rozmiar zbioru zwracanego przez operator to $liczbaZbiorowRodzicow$, czyli $\lceil \param{prawdKrzyzowania} \times \param{rozmiarPopulacji} \rceil$, jednak ponieważ zaokrąglamy wartość $perAlfa$ w górę, to często generowane jest $\param{liczbaAlfa}$ nadmiarowych par.
Można temu zaradzić modyfikując ostatnią pętlę, generującą pary z osobnikami beta, w sposób opisany algorytmem \ref{algorithm:harem_fix}.

\begin{algorithm}
	\caption{Sposób zaradzenia nadmiarowi zwracanych zbiorór \label{algorithm:harem_fix}}
	\begin{algorithmic}[1]
		\Start
		\Operator{opHaremowy}{$populacja$}
			\State $(\dots)$
			\setcounter{ALG@line}{14}
			\While{$|rodzice| < liczbaZbiorowRodzicow$}
				\Var $beta \gets \param{opWyboruBeta}(kandydaci1)$
				\Var $partner \gets \param{opWyboruPartnerow}(kandydaci2)$
				\State $rodzice \gets rodzice \cup \{ \{ beta, partner \} \}$
			\EndWhile
			\State \Return{$rodzice$}
		\EndOperator
	\end{algorithmic}
\end{algorithm}

Takie podejście powoduje, że parametr $\param{wspBeta}$ traci swoje dosłowne znaczenie i określa przybliżony stosunek liczby par rodziców zawierających osobniki beta do liczby wszystkich zwracanych par.

W implementacji wykonanej w niniejszej pracy nie zastosowano tej modyfikacji.
Umotywowane było to małą różnicą między zakładanym i rzeczywistym rozmiarem zbioru par rodziców, oraz faktem, że \defacto generowanie nadmiarowych par powoduje minimalnie lepszą eksploatację przestrzeni rozwiązań (ponieważ jest ona gęściej próbkowana).

Jeżeli w populacji występuje więcej niż 2 płcie ($|\important{G}| > 2$), to jedną z nich należy wyszczególnić jako tą, z której pochodzą osobniki alfa i beta. 
Ponadto, operator ma wtedy więcej parametrów (tyle operatorów wyboru partnerów ile jest niewyróznionych płci), a zamiast jednego partnera (linie \ref{line:harem_alfa_partner_choose} i \ref{line:harem_beta_partner}) wybiera się ich odpowiednio więcej, każdego z wykorzystaniem przeznaczonego do tego operatora wyboru.

\chapter{Eksperymenty} \label{chapter:experiments}

Niniejsza praca ma na celu zbadanie i porównanie różnych podejść do zagadnienia płci wykorzystywanych w algorytmach ewolucyjnych.
Aby to osiągnąć zaimplementowano metody opisane w poprzednim rozdziale i przeprowadzono zestaw eksperymentów, których wyniki zostały porównane.

Ten rozdział zaczyna się od opisu wybranych problemów optymalizacji, na których przeprowadzone zostały badania. Kolejna sekcja zawiera opis implementacji badanych metod. Następnie opisane są procedury wykorzystywane przy eksperymentach. Całość zamknięta jest opisem ich przebiegu i przedstawieniem wyników.

\section{Wybrane problemy optymalizacji}

\todo{NP pełność? knapsack to optymalizacja z ograniczeniami}

Aby zbadać jakość działania wybranych metod zaimplementowano i \fixme{spróbowano rozwiązać} dwa problemy optymalizacji. 
Są to problem komiwojażera (\emph{ang. traveling salesman problem}, w skrócie \emph{TSP}) oraz binarny problem plecakowy.

Problem komiwojażera to zadanie znalezienia minimalnego cyklu Hamiltona w pełnym grafie ważonym. 
Cykl Hamiltona to taki, w którym każdy wierzchołek jest odwiedzany tylko raz (z pominięciem pierwszego wierzchołka, który jest taki sam jak ostatni). 
Graf pełny, to taki, w którym między dowolnymi dwoma wierzchołkami istnieje krawędź, a graf ważony to taki, w którym krawędzie opisane są pewnymi wartościami, nazywanymi wagami. 
Minimalny cykl to taki, dla którego suma wag krawędzi jest najmniejsza.

Problem ten można przełożyć na rzeczywistą sytuację, w której mamy zbiór punktów na mapie (np. miast, reprezentowanych przez wierzchołki grafu) leżących w pewnych odległościach od siebie\footnote{
	Geograficzne odległości między punktami to tylko jedna z możliwych interpretacji.
	Zamiast tego między punktami może być określony czas przejazdu, jego koszt, itd.
	W ogólności, znane są pewne wartości związane z każdymi dwoma punktami, które oznaczają tym gorszą sytuację z punktu widzenia osoby rozwiązującej problem, im są wyższe.
} (które są reprezentowane przez wagi krawędzi). 
Rozwiązanie problemu komiwojażera sprowadza się do minimalizacji długości drogi przechodzącej przez wszystkie punkty. 
Wynik optymalizacji jest cenny w rzeczywistych zastosowaniach, ponieważ pozwala zaoszczędzić zasoby w firmach zajmujących się transportem.

Binarny problem plecakowy (nazywany czasem dyskretnym problemem plecakowym) to zadanie optymalizacji, w którym ze zbioru $n$ par $\{ (k_1, w_1),  (k_2, w_2), \ldots, (k_n, w_n)\}$ należy wybrać taki pozdbiór, dla którego suma pierwszych elementów z pary będzie jak największa, a suma drugich elementów nie przekroczy zadanej wartości $W$.
Problem taki przekłada się na sytuację, w której mamy pewien pojemnik (popularnie nazywany plecakiem, skąd bierze się nazwa problemu) o określonej pojemności $W$ i zestaw przedmiotów, które możemy do niego włożyć. 
Każdy przedmiot jest opisamy parą $(k, w)$, gdzie $k$ reprezetnuje jego wartość, a $w$ jego rozmiar, czy też objętość. 
Rozwiązaniem problemu jest taki zestaw przedmiotów jaki zmieści się w plecaku i będzie miał jak największą wartość. 

Ogólna wersja problemu plecakowego polega na przypisaniu każdemu z przedmiotów (par) liczby naturalnej, określającej ile jego egzemplarzy wkładamy do plecaka, jednak w ramach niniejszej pracy zdecydowano się na binarną wariację tego problemu, która dopuszcza wykorzystanie co najwyżej jednego egzemplarza każdego obiektu.

\todo{może warto opisać zastosowania w real world?}
\fixme{ten akapit jest be}
Opisane problemy zostały wybrane, ponieważ reprezentują dwie klasy zadań powszechnie rozwiązywane przy pomocy algorytmów ewolucyjnych. 
Binarny problem plecakowy to popularne zagadnienie w którym rozwiązania są reprezentowane jako wektory bitów, a problem komiwojażera to znane zagadnienie w którym osobnika przedstawia się jako wektor elementów z danego zbioru (większego niż zbiór wartości binarnych). 

\todo{opisywać rastrigina?}

\section{Implementacja}

W tej sekcji opisane są operatory i ich implementacje wykorzystywane podczas przeprowadzania eksperymentów. 
Pierwsza podsekcja zawiera opis elementów heurystyki niezależnych od problemu, czyli operatorów wyboru i kryterium zarzymania, a kolejne dwie - reprezentacji osobników i operatorów genetycznych wykorzystanych w badaniu wybranych problemów.

\subsection{Komponenty niezależne od problemu}

Niezależnie od tego jaki problem jest rozwiązywany przy pomocy algorytmów ewolucyjnych, pewne elementy są niemalże uniwersalne. 
W tym rozdziale opisane zostaną operatory wyboru oraz kryterium stopu, oraz zestawienie oznaczeń wykorzystywanych w dalszych rozdziałach.

\subsubsection{Operatory wyboru}

Jak zostało zdefiniowane w podsekcji \ref{subsection:new_natSel}, zadaniem operatora wyboru jest zwrócenie pojedynczego elementu ze zbioru osobników.
W standardowych algorytmach ewolucyjnych powszechnie używane są operatory selekcji, które można zaimplementować zgodnie z algorytmem \ref{algorithm:natSel_choose}, korzystające z tego operatora w celu wybrania każdego ze zwracanych osobników.
Ponadto, operatory wykorzystywane w heurystyce DSEA również korzystają z tej abstrakcji.

\paragraph{Operator ruletkowy}

Jedną z popularnych implementacji operatora wyboru jest operator ruletkowy, wykorzystujący pewną dodatnią funkcję (lub operator) przypisującą każdemu osobnikowi tzw. ,,wagę''.
Zwraca on rozwiązanie z prawdopodobieństwem wprost proporcjonalnym do wartości tej funkcji.
Działanie tego operatora standardowo tłumaczy się w następujący sposób:
Wyobraźmy sobie koło ruletki. 
Na całym tym kole zaznaczmy obszary (wycinki koła) przypisane do osobników, w taki sposób, że odpowiedni obszar ma rozmiar wprost proporcjonalny do wagi rozwiązania. 
Następnie zakręćmy tym kołem, a osobnika, do którego obszar będzie tym, na którym zatrzyma się kulka ruletki, zwróćmy.

Istnieją co najmniej dwie standardowe wersje tego operatora, różniące się funkcją przypisującą wagę osobnikom. 
Jedną z nich jest ważenie osobników ich oceną.
W przypadku problemu maksymalizacji przekłada się to bezpośrednio na wymóg nałożony na standardowy operator selekcji, mówiący o tym, że osobniki ,,lepsze'' mają większą szanse na zostanie wylosowanymi.
Odmiana ta jest jednak problematyczna w przypadku problemów minimalizacji, ponieważ ,,lepsze'' osobniki mają wtedy niższą ocenę, a co za tym idzie - zajmują mniej miejsca na wirtualnym kole ruletki, co przekłada się na mniejszą szansę wylosowania.
Jeżeli dla danego problemu znana jest górne ograniczenie funkcji oceny (czyli największa wartość pochodząca z jej przeciwdziedziny), to problem minimalizacji możemy przekształcić do problemu maksymalizacji, poprzez zdefiniowanie nowej funkcji oceny, zwracającą wartość oryginalnego kryterium odjętą od jego górnego ograniczenia\footnote{
	Prosta zmiana znaku kryterium również sprowadza problem minimalizacji do problemu maksymalizacji, jednak nie pozwala na zastosowanie operatora ruletkowego, ponieważ waga osobnika musi być dodatnia. 
	Alternatywne podejście, polegające na użyciu odwrotności wartości kryterium również nie zawsze jest możliwe do użycia, ponieważ wartość oceny może wynosić 0.
}.
W takiej sytuacji, osobniki możemy ważyć przy pomocy ich ,,rangi'', czyli pozycji po posortowaniu od najgorszych do najlepszych.
Dzięki temu najgorszy osobnik zajmuje jedną jednostke obszaru koła ruletki, drugi - dwie jednostki, a najlepszy - $n$ jednostek, gdzie $n$ to rozmiar zbioru na którym stosuje się operator selekcji.
Dzięki temu, że operator korzysta jedynie z relacji porządku między osobnikami $\minoritySpecimenRel$ (wynikającej z relacji porządku określonej na ich ocenach $\minorityEvalRel$) nie występuje tu wcześniej opisany problem, więc operator jest użyteczny zarówno w problemach minimalizacji, jak i maksymalizacji.

\begin{algorithm}[h]
	\caption{Schemat działania ruletkowego operatora wyboru \label{algorithm:roulette}}
	\begin{algorithmic}[1]
		\Input{
			$populacja$ \Comment{Populacja z której wybierany jest osobnik}
		}
		\Output{
			wybrany osobnik
		}
		\Params{
			$\param{waga}$ \Comment{Funkcja wagi, np. funkcja oceny lub ranga}
		}
		\Start
		\Operator{opRuletkowy}{$populacja$}
			\Var \label{line:roulette_sort} 
			$posortowane \gets$ $populacja$ posortowana malejąco po wartości funkcji $\param{waga}$
			\Var \label{line:roulette_sum} 
			$sumaWag \gets \sum_{s \in populacja} \param{waga}(s)$
			\Var \label{line:roulette_random} 
			$wybrane \gets random(\range{0}{sumaWag})$
			\Var \label{line:roulette_k} 
			$k \gets 0$
			\For{$s \in posortowane$} \label{line:roulette_loop} 
			\Comment{w kolejności określonej w linii \ref{line:roulette_sort}}
				\If{$wybrane \geq k \wedge wybrane < k + \param{waga}(s)$}
				\label{line:roulette_if} 
					\State \Return $s$ \label{line:roulette_return_loop} 
				\Else
					\State $k \gets k + \param{waga}(s)$ \label{line:roulette_incr} 
				\EndIf
			\EndFor
			\State \Return ostatni element $posortowane$ \label{line:roulette_return_last} 
		\EndOperator
	\end{algorithmic}
\end{algorithm}

Schemat działania operatora ruletkowego jest opisany przy pomocy algorytmu \ref{algorithm:roulette}.

Pierwszym krokiem działania operatora jest posortowanie populacji wejściowej tak, aby osobniki o większej wadze (czyli o większym prawdopodobieństwie wyboru) znalazły się bliżej początku posortowanego wektora $posortowane$ (w linii \ref{line:roulette_sort}).
Następnie, obliczana jest suma wag wszystkich osobników, przechowywana w zmiennej $sumaWag$ (linia \ref{line:roulette_sum}).
W kolejnych krokach wybierana jest losowa wartość $wybrane$ z przedziału $\range{0}{sumaWag}$ (w linii \ref{line:roulette_random}) i inicjalizowana jest zmienna pomocniczna $k=0$ (w linii \ref{line:roulette_k}).
W pętli, rozpoczynającej się w linii \ref{line:roulette_loop} przeszukiwany jest wektor $posortowane$, w poszukiwaniu takiego osobnika, którego waga jest mniejsza niż $wybrane-k$, ale większa lub równa $k$ (warunek w linii \ref{line:roulette_if}). 
Jeżeli taki osobnik zostanie znaleziony, to zostaje on zwrócony jako wynik działania operatora (linia \ref{line:roulette_return_loop}), a w przeciwnym wypadku jego waga zostaje dodana do wartości $k$ (w linii \ref{line:roulette_incr}).
Jeśli żaden z osobników nie spełnia tych warunków, to zwracany jest ostatni osobnik, z najmniejszą wagą (linia \ref{line:roulette_return_last}).

\begin{figure}[h]
	\caption{Działanie ruletkowego operatora wyboru \label{figure:roulette_example}}
	\centering
	\begin{tikzpicture}[>=triangle 60]
	
		%axis
		\draw[->] (-1, 0) -- (13, 0);
		
		\draw (0, 0.25) -- (0, -0.25) node [below] {$0$};
		
		\draw (6, 0.25) -- (6, -0.25);
		\draw (10, 0.25) -- (10, -0.25);
		
		\draw (12, 0.25) -- (12, -0.25) node [below] {$sumaWag$};
	
		%braces
		\draw [decorate,decoration={brace,amplitude=15pt},xshift=0pt,yshift=0pt] (0, 0) -- (6, 0) node [black,midway,yshift=20pt] {$\param{waga}(s_0)$};
				
		\draw [decorate,decoration={brace,amplitude=15pt},xshift=0pt,yshift=0pt] (6, 0) -- (10, 0) node [black,midway,yshift=20pt] {$\param{waga}(s_1)$};
		
		\draw [decorate,decoration={brace,amplitude=15pt},xshift=0pt,yshift=0pt] (10, 0) -- (12, 0) node [black,midway,yshift=20pt] {$\param{waga}(s_2)$};
		
		%size arrows
		%\draw[<->] (0, 0.3) -- (6, 0.3) node [black,midway,yshift=10pt] {$\param{waga}(s_0)$};
		
		%\draw[<->] (6, 0.3) -- (10, 0.3) node [black,midway,yshift=10pt] {$\param{waga}(s_1)$};
		
		%\draw[<->] (10, 0.3) -- (12, 0.3) node [black,midway,yshift=10pt] {$\param{waga}(s_2)$};
		
		%randoms
		\draw[->] (0, -1.5) node[below,anchor=south,yshift=-20pt] {$a$} -- (0, -0.75) ;
		\draw[->] (1, -1.5) node[below,anchor=south,yshift=-20pt] {$b$} -- (1, -0.75) ;
		\draw[->] (6, -1.5) node[below,anchor=south,yshift=-20pt] {$c$} -- (6, -0.75) ;
		\draw[->] (8, -1.5) node[below,anchor=south,yshift=-20pt] {$d$} -- (8, -0.75) ;
		\draw[->] (12, -1.5) node[below,anchor=south,yshift=-20pt] {$e$} -- (12, -0.75) ;
	\end{tikzpicture}
\end{figure}

Działanie tak opisanego operatora obrazuje rysunek \ref{figure:roulette_example}. 
Na osi zaznaczono przykładowe wagi 3 osobników, w sytuacji w której $posortowane = [ s_0, s_1, s_2 ]$ oraz kilka przykładowych wartości ($a$, $b$, $c$, $d$, $e$) jakie może przyjąć $wybrane$ .
Jeżeli $wybrane=a$ lub $wybrane=b$, to zwrócony zostanie osobnik $s_0$, ponieważ $k$ będzie równe $0$ i $wybrane$ znajdzie się w odpowiednim przedziale.
W przeciwnym wypadku $k$ zostanie zwiększone do wartości $\param{waga}(s_0)$.
Wtedy, jeżeli $wybrane=c$ lub $wybrane=d$, to zwrócony zostanie osobnik $s_1$, z tego samego powodu.
Jeżeli jednak $wybrane=e$, to $k$ przyjmie kolejno wartości $\param{waga}(s_0) + \param{waga}(s_1)$ i $\param{waga}(s_0) + \param{waga}(s_1) + \param{waga}(s_2)$.
W takiej sytuacji warunek sprawdzany w pętli nie zostanie spełniony, więc zwrócony zostanie osobnik $s_2$.

\paragraph{Operator turniejowy}

Drugą powszechnie stosowaną metodą selekcji jest operator turniejowy (\emph{ang. tourney select}).
Jego działąnie polega na wylosowaniu z równym pradopodobieństwem pewnej ilości osobników i zwróceniu najlepszego spośród nich.
Zbiór kandydatów do zwrócenia nazywa się \emph{turniejem}, a jego rozmiar (czyli ilość rozwiązań które są między sobą porównywane) nazywany jest \emph{rozmiarem turnieju} i jest parametrem operatora.

\begin{algorithm}[h]
	\caption{Schemat działania turniejowego operatora wyboru \label{algorithm:tourney}}
	\begin{algorithmic}[1]
		\Input{
			$populacja$ \Comment{Populacja z której wybierany jest osobnik}
		}
		\Output{
			$wynik$ \Comment{Wybrany osobnik}
		}
		\Params{
			$\param{n}$ \Comment{Rozmiar turnieju}
		}
		\Start
		\Operator{opTurniejowy}{$populacja$}
			\Var $turniej \gets \emptyset$
			\While{$|turniej|<\param{n}$}
				\State $turniej \gets turniej \cup random(populacja \setminus turniej)$
			\EndWhile
			\Var $wynik \gets NULL$
			\For{$s \in turniej$}
				\If{$wynik = NULL \vee (wynik, s) \in \minoritySpecimenRel$}
					\State $wynik \gets s$
				\EndIf
			\EndFor
			\State \Return $wynik$
		\EndOperator
	\end{algorithmic}
\end{algorithm}

Schemat działania operatora turniejowego jest opisany przy pomocy algorytmu \ref{algorithm:roulette}.

Działanie operatora rozpoczyna się od inicjalizacji zbioru $turniej$ na zbiór pusty.
Następnie, póki zbiór ten nie osiągnie rozmiaru $n$ dodawane są do niego osobniki losowo wybierane (bez powtórzeń) z populacji.
W kolejnym kroku $turniej$ jest przeszukiwany pod kątem rozwiązania lepszego od pozostałych.
Polega to na zainicjalizowaniu pomocniczej zmiennej $wynik$ na wartość $NULL$ (czyli abstrakcyjną, pustą wartość) i sprawdzeniu każdego z osobników ze zbioru $turniej$.
Jeżeli zmienna $wynik$ ma wartość $NULL$ (czyli pętla dopiero się rozpoczęła) lub rozwiązanie $s$ sprawdzane w danym momencie jest lepsze od wartości tej zmiennej (co sprowadza się do sprawdzenia, czy dana para osobników jest w relacji lepszego dopasowania $\minoritySpecimenRel$), to wartość $wynik$ jest nadpisywana przez $s$.
Wynikiem działania operatora jest znaleziony w ten sposób najlepszy osobnik spośród losowo wybranych, czyli wartość $wynik$.

\todo{referencje do linii}

\subsubsection{Kryterium stopu}

Jak zostało opisane w podsekcji \ref{subsection:stop} zadaniem kryterium stopu jest przerwanie działania heurystyki w wybranym momencie.
Ma to na celu ograniczenie czasu działania procesu do skończonej wartości.

Najprostszą implementacją tego warunku jest zatrzymanie heurystyki po przetworzeniu określonej liczby pokoleń.
Działanie takiego operatora opisane jest przy pomocy algorytmu \ref{algorithm:stdStop}

\begin{algorithm}
	\caption{Warunek zatrzymania po określonej liczbie pokoleń \label{algorithm:stdStop}}
	\begin{algorithmic}[1]
		\Context{
			$pokolenie$ \Comment{Numer obecnego pokolenia, liczony od 1}
		}
		\Params{
			$\param{max}$ \Comment{Liczba pokoleń które należy przetworzyć}
		}
		\Output{
			1 - oznaczające, że należy przerwać działanie heurystyki, lub 0 w przeciwnym wypadku
		}
		\Start
		\Operator{krytStopu}{}
			\If{$pokolenie \leq \param{max}$}
				\State \Return 1
			\Else
				\State \Return 0
			\EndIf
		\EndOperator
	\end{algorithmic}
\end{algorithm}

Jego działanie jest trywialne i sprowadza się do sprawdzenia odpowiedniego warunku X i zwrócenia 1 X lub 0 X w zależności od jego prawdziwości.

\todo{referencje do linii}

\subsubsection{Wykorzystane implementacje i oznaczenia}

W niniejszej pracy wykorzystano operator losowy, ruletkowy ważony rangą, oraz operatory turniejowe o rozmiarze 2 i 3. 
Wykorzystywane są one wraz z operatorem selekcji naturalnej opisanym algorytmem \ref{algorithm:natSel_choose} oraz operatorami selekcji płciowej opisanymi za pomocą algorytmów \ref{algorithm:common_genSel} i \ref{algorithm:harem}.
Ponadto, niezależnie od eksperymentu wykorzystano kryterium zatrzymania opisane w poprzednim paragrafie. 

Tabela \ref{table:op_symbols} przedstawia oznaczenia różnych elementów wraz z ich opisem.
Przykładowo, zapis \opName{stdGenSel}($\top$, \opName{R}, \opName{TS}(2)) oznacza standardowy operator selekcji naturanej, parametryzowany przez $\param{plecMaZnaczenie}=\top$, wykorzystujący operator losowy jako $\param{opWyboru1}$ i operator turniejowy (z rozmiarem turnieju równym 2) jako $\param{opWyboru2}$.

\begin{table}
	\caption{Oznaczenia operatorów \label{table:op_symbols}}
	\begin{tabularx}{\linewidth}{|c|X|}
		\hline
		\textbf{Oznaczenie} & \textbf{Znaczenie} \\
		\hline \hline
		\opName{R} & Losowy operator wyboru $random(X)$ \\ 
		\hline
		\opName{RS} & Ruletkowy operator wyboru \\ 
		\hline
		\opName{TS}($n$) & Turniejowy operator wyboru o rozmiarze turnieju n \\ 
		\hline
		\opName{natSel}(X) & Operator selekcji naturalnej opisany algorytmem \ref{algorithm:natSel_choose}, korzystający z operatora wyboru X \\
		\hline
		\opName{stdGenSel}(p, W1, W2) & Operator selekcji płciowej używany do realizacji dotychczasowych rozwiązań, opisany algorytmem \ref{algorithm:common_genSel}, parametryzowany przez $\param{plecMaZnaczenie}=p$, $\param{opWyboru1}=W1$ oraz $\param{opWyboru2}=W2$ \\
		\hline
		\opName{harem}(a, b, WA, WB, WP) & Proponowany haremowy operator selekcji płciowej, opisany algorytmem \ref{algorithm:harem} (bez zmian opisanych algorytmem \ref{algorithm:harem_fix}), wykorzystujący $\param{liczbaAlfa}=a$, $\param{wspBeta}=b$, $\param{opWyboruAlfa}=WA$, $\param{opWyboruBeta}=WB$, $\param{opWyboruPartnerow}=WP$. \\
		\hline
	\end{tabularx}
\end{table}

W pracy przyjęto co najwyżej 2 płcie osobników. Jeżeli płec była tylko jedna, to $\important{G} = \{ \odot \}$, w przeciwnym wypadku $\important{G} = \{ \male, \female \}$.

\subsection{TSP}
działanie operatorów, etc
\subsection{Knapsack}
...
\section{Procedury eksperymentów}
eksploracja z nawrotami/czysty przegląd/inne procedury z etapu 2
\section{Przeprowadzone eksperymenty}
Wyjaśnić strukture
\subsection{TSP}
\subsubsection{Initial}
\paragraph{Konfiguracja}
zakresy parametrów, parametry początkowe, ilość nawrotów i powtórzeń
\paragraph{Przebieg}
Kolejno znajdowane konfiguracje
\paragraph{Wyniki}
10 najlepszych max, 10 najlepszych avg, zestawić w tabelki, opisać
1 najlepszy pokazać i opisać przebieg
\subsubsection{Tweak}
...
\subsubsection{Compare}
...
\subsubsection{SexualGA}
... - co tu będzie?
\subsubsection{GGA}
... - jw?
\subsection{Knapsack}
...


\chapter{Wnioski i spostrzeżenia}
\chapter{Dalsze drogi rozwoju}



\pagestyle{plain}

\todo{wywalić listy (?), poradzić sobie z podwójną bibliografią (patrz: spis treści)}

\listoffigures
\listoftables
\listof{signature}{Spis sygnatur}
\listof{algorithm}{Spis algorytmów}

\bibliographystyle{iisthesis}
\bibliography{bibliografia}

\appendix \chapter{Pełne wyniki badań}

\end{document}

