% compile with XeLaTeX
% !TeX spellcheck = pl_PL
% !TeX encoding = UTF-8
\documentclass[twoside]{iisthesis}
% ---
\usepackage[MeX]{polski}
%\usepackage[utf8]{inputenc}
\usepackage{graphicx}

\usepackage{fontspec}
\usepackage[table,xcdraw]{xcolor}

% Dodane przeze mnie d
\usepackage{fancyvrb} % dla srodowiska Verbatim
\usepackage{color}
\usepackage{lscape}

%pakiety do grafiki
\usepackage{pstricks}
\usepackage{pst-tree}

% definicje kolorow
\definecolor{ciemnoSzary}{rgb}{0.15,0.15,0.15}
\definecolor{szary}{rgb}{0.5,0.5,0.5}
\definecolor{jasnoSzary}{rgb}{0.2,0.2,0.2}
\definecolor{stal}{rgb}{0.75, 0.75, 0.75}

% Konfiguracja verbatima
\fvset{
	frame=single,
	numbers=left,
	fontsize=\footnotesize,
	numbersep=12pt,
%	framerule=.5mm,
	rulecolor=\color{ciemnoSzary},
%	fillcolor=\color{jasnoSzary},
	framesep=4pt,
	stepnumber=1,
	numberblanklines=false,
	tabsize=2,
%	formatcom=\color{szary}
}

% % % % % % % % % % % % % % % %
% MY CONTENT
% % % % % % % % % % % % % % % %


\usepackage{tabularx}
\usepackage{tabulary}
\usepackage{placeins}
\usepackage{algpseudocode}
\usepackage[chapter]{algorithm}
\usepackage{mathtools}
\usepackage{float}
\usepackage{tocloft}
\usepackage{tocbibind}
\usepackage{amsfonts}
\usepackage{nicefrac}

\usepackage[labelsep=period]{caption}

\usepackage{tikz}
\usetikzlibrary{arrows}

\algnewcommand\Var{\State\textbf{var\ }}
\algnewcommand\To{\textbf{ to }}

\algnewcommand{\Params}[1]{%
	\Statex \textbf{Potrzebne zmienne, parametry i operatory:}
	\Statex \hspace*{\algorithmicindent}\parbox[t]{.8\linewidth}{\raggedright #1}
}

%\algnewcommand{\MyComment}[1]{\Comment{\parbox[t]{.5\linewidth}{#1}}}
%\algnewcommand{\MyComment}[1]{\Comment{\begin{flushright}#1\end{flushright}}}
%\algnewcommand{\MyComment}[1]{\Comment{\begin{flushright}\parbox[t]{\linewidth}{#1}\end{flushright}}}
%\algnewcommand{\MyComment}[1]{\begin{flushright}$\rhd$\quad #1\end{flushright}}
%\algnewcommand{\MyComment}[1]{\parbox[t]{\linewidth}{\begin{flushright}$\rhd$\quad #1\end{flushright}}}

\newcommand{\defacto}{\emph{de facto }}
\newcommand{\ergo}{\emph{ergo }}
\newcommand{\Defacto}{\emph{De facto }}
\newcommand{\Ergo}{\emph{Ergo }}

\newcommand{\todo}{\colorbox{red}}

\newfloat{signature}{H}{sig}
\floatname{signature}{Sygnatura}

\floatname{algorithm}{Algorytm}


\newcommand{\numberSet}[1]{\mathbb{#1}}
\newcommand{\important}[1]{\mathcal{#1}}
\newcommand{\R}{\mathbf{R}}
\newcommand{\minorityEvalRel}{{\R}_{\prec}}
\newcommand{\minoritySpecimenRel}{{\R}_{\lhd}}
\newcommand{\param}[1]{\mathtt{#1}}
\newcommand{\variable}[1]{\mathsf{#1}}
%\newcommand{\variable}[1]{\textbf{#1}}
%\newcommand{\inputVar}[1]{\variable{#1_{I}}}
%\newcommand{\outputVar}[1]{\variable{#1_{O}}}
\newcommand{\inputVar}[1]{\variable{\overline{#1}}}
\newcommand{\outputVar}[1]{\variable{\underline{#1}}}

%\newcommand{\circled}[1]{\textcircled{\small{#1}}}
%\newcommand{\circled}[1]{\tikz \node[anchor=south west, draw,circle, inner sep=0pt, minimum size=7mm, pos=0.5]{#1};}
\newcommand{\circled}[1]{ \textcircled{\scriptsize{#1}} } 


\newcommand{\img}[1]{\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{pictures/#1}}
\newcommand{\graph}[1]{\input{graphs/#1}}
%\newcommand{\vectorGraphics}[1]{\input{vector/#1}}

\newcolumntype{s}{>{\hsize=.5\hsize}c}

%\newcommand{\largeVMiddle}[2][|]{ \multicolumn{1}{#1m#1}{ \Large #2 \par } }

%uncomment for double spacing 
%\usepackage{setspace}
%\doublespacing

\begin{document}

\title{Algorytmy ewolucyjne z uwzględnieniem płci w rozwiązywaniu wybranych problemów}
\author{Filip Malczak}
\advisor{dr hab. inż. Urszula Markowska-Kaczmar}
\instituteLogo{logos/pwr}
\slowaKluczowe{algorytmy ewolucyjne\\płeć\\operator selekcji}

\date{\number\the\year}

% Wstawienie abstractu pracy
	%\input {abstract}
	
\abstractSH{
Bardzo krótkie streszczenie w którym powinno się znaleźć omówienie tematu pracy i poruszanych terminów. Tekst ten nie może być zbyt długi. 
}

\abstractPL{
	Abstrakt
}
\abstractEN{
	Abstrakt
}

\maketitle
\textpages

\chapter{Wprowadzenie}

Optymalizacja to zadanie wyboru najlepszego elementu z danego zbioru (nazywanego przestrzenią rozwiązań). 
Przez najlepszy rozumiemy taki, dla którego tzw. funkcja oceny, czy też kryterium przyjmuje najwyższą (w zadaniu maksymalizacji) lub najniższą (w zadaniu minimalizacji) wartość. 
Z takim problemem spotykamy się wszędzie tam, gdzie chcemy zwiększyć lub zmniejszyć jakieś wskaźniki, np. zminimalizować koszta produkcji lub transportu, albo zmaksymalizować zyski ze sprzedaży lub jakość klasyfikacji.

Jeżeli funkcję oceny można zapisać w postaci analitycznej (np. w formie układu równań różniczkowych) to zazwyczaj możemy ją optymalizować metodami numerycznymi, analitycznymi lub algebraicznymi. 
Istnieją sytuacje, w których nie możemy skorzystać z żadnej z tych metod. 
Powody tego mogą być różne, m.in. możemy nie znać postaci funkcji (bo np. reprezentuje ona obserwacje jakiegoś procesu lub zjawiska), funkcja zapisana analitycznie może nie spełniać pewnych kryteriów (np. nie być różniczkowalna), lub obliczenia mogą zajmować zbyt wiele czasu (np. pełne przeszukiwanie przestrzeni rozwiązań będącej iloczynem kartezjańskim dużej liczby dużych, czy wręcz nieskończonych zbiorów). 
Często nie jest nam potrzebne globalne optimum (tzn najlepsze rozwiązanie ze wszystkich możliwych), a wystarczy rozwiązanie jak najlepsze (tzn. optimum lokalne, lub punkt o wartości kryterium zbliżonej do wartości kryterium optimum globalnego).

Do takich zastosowań przeznaczone są metody nazywane heurystykami. 
W zależności od źródła definicje tego pojęcia są różne. 
W dziedzinie informatyki, a w szczególności obliczeń miękkich i sztucznej inteligencji, termin ten możemy nieformalnie opisać jako algorytm który nie daje gwarancji uzyskania poprawnego wyniku.
Heurystyki stosowane są wszędzie tam, gdzie nie mamy rzeczywistej możliwości uzyskania wyniku, więc dowolne jego przybliżenie będzie lepsze niż brak jakichkolwiek rezultatów.

\section{Algorytmy ewolucyjne} \label{section:eaShortDesc}

Ewolucja to proces zachodzący w naturze odpowiedzialny za dopasowywanie się osobników danego gatunku do środowiska w jakim żyją. 
Podstawą tego procesu jest zasada przetrwania lepiej przystosowanych osobników oraz zjawiska dziedziczenia i mutacji.

Zgodnie z powyższą zasadą, jednostki lepiej dopasowane do środowiska mają większą szansę na przeżycie, a co za tym idzie, na wydanie potomstwa.
Oznacza to, że rodzice większości osobników z kolejnego pokolenia będą radzić sobie w tym środowisku lepiej niż pozostała część populacji.

Zjawisko dziedziczenia polega na przekazywaniu cech rodziców dzieciom. 
Zachodzi ono podczas rozmnażania, a więc między dwojgiem rodziców i ich potomstwem. 
Kod genetyczny potomstwa tworzony jest przez losowe łączenie odpowiednich części kodu genetycznego rodziców, dzięki czemu kolejne pokolenie dzieli ich cechy. 
W ten sposób niektóre osobniki przejmą od rodziców te cechy, które pozwalały im się dopasować do środowiska.
Część osobników przejmie jednak nie tylko cechy poprawiające ich szansę przetrwania, ale również cechy negatywne, co przełoży się na ich gorsze dopasowanie.

Mutacja to zjawisko zachodzenia losowych zmian w kodzie genetycznym osobnika, dzięki którym ma on szansę zyskać nowe cechy, co w niektórych przypadkach doprowadzi do lepszego dopasowania.
Osobniki z przypadkowymi zmianami, które poprawiają ich dopasowanie mają większe szanse na przeżycie i wydanie potomstwa.
Zmiany te więc zostać rozpropagowane wśród osobników przyszłych pokoleń.

Algorytmy ewolucyjne to rodzina heurystyk naśladujących proces ewolucji w celu optymalizacji \cite{davis1991handbook}. 
Pojedynczy element przestrzeni rozwiązań jest w nich nazywany osobnikiem. 
Osobniki możemy między sobą porównywać pod względem wartości optymalizowanej funkcji dla nich, a relacja mniejszości (dla problemów minimalizacji) lub większości (dla problemów maksymalizacji) reprezentuje relację bycia lepiej przystosowanym do środowiska. 
Ponadto, na osobnikach określone są operatory mutacji i krzyżowania, które mają na celu symulację odpowiednich zjawisk występujących w przyrodzie. 
Heurystyka polega na wielokrotnym przetworzeniu populacji (czyli zbioru osobników) poprzez zastosowanie każdego z operatorów z pewnym prawdopodobieństwem. 
W każdym kroku (nazywanym w tym przypadku pokoleniem) do dotychczasowej populacji dołączane są wyniki ich działania tych operatorów, a następnie wybierana jest nowa populacja, używana w kolejnym kroku. 
Aby odwzorować zasadę przetrwania najlepiej dopasowanych osobników, do kolejnej populacji wybierane są z wyższym prawdopodobieństwem osobniki lepiej przystosowane.

W naturze rozmnażanie się osobników wielu gatunków jest ściśle związane ze zjawiskiej podziału gatunku na płcie. 
Bardziej szczegółowy opis tego zjawiska znajduje się w rozdziale \ref{chapter:proposed}. 
W dostępnej literaturze dotyczącej tematu algorytmów ewolucyjnych rzadko można znaleźć prace, w których uwzględnia się ten aspekt procesu ewolucji (patrz: rozdział \ref{chapter:literature}). 
Powodem tego jest raczej chęć uproszczenia działania samej heurystyki niż lepsza jakość wyników uzyskiwanych z pominięciem tego aspektu (\cite{GGA}, \cite{SexualGA}). 

\section{Cele pracy}

Pierwszym celem niniejszej pracy jest opracowanie formalnego opisu algorytmu ewolucyjnego uwzględniającego płeć.
Schemat heurystyki jest w pewnym stopniu dowolny, a publikacje z tej dziedziny nie używają jednego wspólnego formalizmu, co utrudnia jednoznaczne porównywanie ich działania.
Spełnienie tego celu powinno doprowadzić do określenia konkretnego schematu, który pozwoli zaimplementować wybrane istniejące rozwiązania oraz zaproponowane rozwiązanie autorskie.

Kolejnym celem jest opis i implementacja wybranych istniejących rozwiązań wykorzystujących płeć w ramach wcześniej opisanego schematu.
Poza implementacją tych metod, powinno powstać narzędzie badawcze, które pozwoli na klarowne porównanie ich działania.

Cel trzeci to opracowanie nowego podejścia uwzględniającego płeć.
Jest to główny cel tej pracy, mający wnieść coś nowego do dziedziny algorytmów ewolucyjnych.

Ostatnim celem jest zbadanie wcześniej opisanych i zbadanych podejść.
Polega to na zebraniu miar jakości działania algorytmów ewolucyjnych dla każdego z nich i porównanie ich ze sobą.

\chapter{Algorytmy ewolucyjne} \label{chapter:eaDesc}
Algorytmy ewolucyjne to rodzina heurystyk populacyjnych, tzn. heurystyk które operują i zwracają zbiór rozwiązań zamiast pojedynczego wyniku. Podstawowe pojęcia w tej dziedzinie to osobnik, populacja, ocena (nazywana też funkcją oceny, kryterium lub funkcją dopasowania), operator krzyżowania, operator mutacji, operator selekcji i warunek stopu (nazywany też warunkiem zakończenia lub przerwania).
Poniższe rozdziały opisują szczegółowe znaczenie wymienionych pojęć, sposób zastosowania heurystyki do rozwiązania problemu oraz sposoby oceny działania heurystyki.
\section{Działanie}

Wymienione wyżej pojęcia określają elementy heurystyki które musimy zdefiniować aby ją zastosować w celu rozwiązania problemu. Każde z tych pojęć niesie ze sobą nie tylko znaczenie i zastosowanie wzorowane na przyrodzie, ale również ograniczenia nałożone na realizację danego elementu, również wynikające z natury.

W tabeli \ref{table:signature_conventions} zostały pokazane konwencje dotyczące znaczenia czcionek używane w tej pracy.

%\newcommand{\important}{\mathcal}
%\newcommand{\relation}{\mathsf}
%\newcommand{\numberSet}{\mathbb}
%\newcommand{\operator}{\mathtt}

\begin{table}
	\caption{Konwencje dotyczące czcionek \label{table:signature_conventions}}
	\centering
	\begin{tabular}{cl}
		$\param{operator}, \param{n}$ & operatory i parametry heurystyki \\
		$\variable{k}$ & parametry zależne od realizacji operatorów \\
		$T, p$ & zbiory i parametry pomocnicze \\
		$\important{S}$ & zbiory używane w definicjach \\
		$\R$ & relacje \\
		$\numberSet{N}$ & zbiory liczbowe
	\end{tabular}
\end{table}

\subsection{Pojęcie operatora} \label{subsection:operator}

W dalszych rozdziałach będziemy używać pojęcia ,,\textbf{operator}'', które jest zbliżone do pojęcia funkcji. Różnica między tymi dwoma terminami jest taka, że funkcja musi zawsze zwrócić tą samą wartość dla tego samego argumentu, podczas gdy takie ograniczenie nie musi być spełnione dla operatora. Innymi słowy pojęcie operatora pokrywa się z pojęciem funkcji z imperatywnych języków programowania, ale nie pokrywa się z funkcją w rozumieniu matematycznym.

Operator możemy też rozumieć jako zmienną losową opisaną rozkładem parametryzowanym argumentami operatora.

Warto pamiętać, że każda funkcja (w rozumieniu matematycznym) jest operatorem.

Do operatorów możemy stosować niektóre pojęcia używane w stosunku do funkcji. Przez \emph{dziedzinę} operatora rozumiemy przestrzeń dozwolonych argumentów operatora, a przez \emph{przeciwdziedzinę} - zbiór wartości które może zwrócić. Aby uzyskać \emph{wynik} operatora (czyli wartość przez niego zwracaną) \emph{stosujemy} ten operator na \emph{argumentach}.

Dodatkowo, operator możemy \emph{sparametryzować} aby uzyskać inny operator. Przez \emph{parametry} rozumiemy argumenty które w ramach danego ciągu obliczeń są stałe. Przykładowo, operator sąsiedztwa o określonym rozmiarze \emph{d} dla punktu \emph{(x, y)}:

\begin{displaymath}
	sasiedztwo((x, y), d) \in [x-d, x+d] \times [y-d, y+d]
\end{displaymath}

możemy sparametryzować rozmiarem sąsiedztwa, aby uzyskać operator sąsiedztwa o konkretnym rozmiarze:

\begin{displaymath}
sasiedztwo_5 (P) = sasiedztwo (P, 5)
\end{displaymath}

\Defacto każdy operator opisywany w tej pracy może być parametryzowany. W kolejnych rozdziałach przyjęto konwencję według której definiując nowy operator zapisywana jest jego minimalna dziedzina, co nie oznacza, że podczas realizacji nie może on być parametryzowany. Analogicznie stwierdzenie, że operator powinien przyjmować daną liczbę argumentów nie oznacza, że nie może on przyjmować ich więcej. Innymi słowy sygnatura postaci:

\begin{displaymath}
operator: D \rightarrow C
\end{displaymath}

gdzie $D$ oznacza dziedzinę, a $C$ przeciwdziedzinę, jest równoważna z:

\begin{displaymath}
operator: D \times P \rightarrow C
\end{displaymath}

gdzie $P$ oznacza przestrzeń parametrów, zależnych od realizacji operatora.

\subsection{Osobnik, populacja i ocena}

Podstawowym pojęciem używanym w opisywanej heurystyce jest \textbf{osobnik}. Jest to abstrakcja pojedynczego rozwiązania, nawiązująca do pojedynczego żywego stworzenia charakteryzującego się pewnymi cechami które wpływają na prawdopodobieństwo jego przeżycia i wydania potomstwa. Pojęciem symulującym wpływ cech na prawdopodobieństwo przeżycia jest \textbf{funkcja oceny}. Dodatkowo wprowadzamy pojęcie \textbf{populacji}, czyli zbioru osobników istniejących w danym momencie w procesie ewolucji.

Realizacją osobnika w heurystyce jest reprezentacja rozwiązania problemu, a realizacją populacji - zbiór rozwiązań, czyli podzbiór przestrzeni rozwiązań.

Ważniejszym pojęciem jest funkcja oceny. Wbrew nazwie nie musi być to funkcja w rozumieniu matematycznym, a operator (patrz: rozdział \ref{subsection:operator}) \footnote{Stochastyczną funkcję oceny możemy zastosować na przykład w sytuacji, w której za pomocą algorytmu ewolucyjnego szukamy konfiguracji innej heurystyki. Osobnikiem w takiej sytuacji może być zestaw parametrów konfigurowanej heurystyki, a oceną - średnia jakość działania dla kilku uruchomień.}. Jego dziedziną powinna być przestrzeń możliwych osobników, a przeciwdziedziną dowolny zbiór na którym możemy określić relację porządku. Relacja ta odpowiada relacji bycia lepiej przystosowanym do środowiska w rzeczywistym procesie ewolucji.

Standardową realizacją osobnika jest wektor binarny, który sprawdza się w wielu zastosowaniach i jest prosty w realizacji programowej lub sprzętowej. Algorytmy ewolucyjne korzytające z takiej reprezentacji nazywane są algorytmami genetycznymi. Reprezentacja jest jednak uzależniona od rozwiązywanego problemu. Często wykorzystuje się bardziej skomplikowane przedstawienia rozwiązania, jak wektor wartości z pewnego zbioru (skończonego, lub nieskończonego, jak liczby), czy drzewo \cite{gen_prog} (np. dla problemów aproksymacji funkcji \cite{gen_prog_foo_approx}).

Istnieją implementacje i narzędzia do obliczeń ewolucyjnych które rozróżniają pojęcie genotypu osobnika (czyli wewnętrznej reprezentacji rozwiązania, na której stosujemy operatory genetyczne takie jak krzyżowanie i mutacja) i jego fenotypu (czyli reprezentacji zewnętrznej, na podstawie której oceniamy osobnika), jednak jest to jedynie abstrakcja umożliwiająca czytelniejsze zapisanie realizacji odpowiednich pojęć w języku programowania. Niniejsza praca nie wprowadza takiego rozróżnienia, ponieważ nie zmienia ono w żadnym stopniu jakości działania heurystyki i nie jest związane z tematem badań.

\begin{signature}
	\caption{Osobnik \label{signature:specimen}}
	\begin{align}
	osobnik \in &\important{S}
	\end{align}
	Zbiór $\important{S}$ to przestrzeń rozwiązań.
\end{signature}

\begin{signature}
	\caption{Funkcja oceny \label{signature:eval}}
	\begin{align}
		\param{funkcjaOceny}: &\important{S} \rightarrow \important{E} \\
		\exists \minorityEvalRel \subset &\important{E} \times \important{E} \\
		\minoritySpecimenRel \gets &\left\{ (x, y): (\param{funkcjaOceny}(x), \param{funkcjaOceny}(y)) \in \minorityEvalRel \right\}
	\end{align}
	Zbiór $\important{E}$ to zbiór możliwych ocen osobnika, 
	a $\minorityEvalRel$ to relacja porządku na nim określona. Ponadto określamy relację lepszego dopasowania $\minoritySpecimenRel$, porządkującą przestrzeń osobników według porządku określonego na ich ocenach. 
\end{signature}

\subsection{Operatory genetyczne}

Dwa podstawowe operatory używane w algorytmach ewolucyjnych to \textbf{operator mutacji} i \textbf{operator krzyżowania}. Są one stosowane na osobnikach z populacji w danym pokoleniu w celu przeszukania lokalnej przestrzeni rozwiązań. W zależności od implementacji, kolejność stosowania operatorów jest różna, a wyniki ich zastosowania są dołączane do całej populacji w danym pokoleniu, lub składają się na nową populację, używaną w kolejnym pokoleniu. W niniejszej pracy stosowane będzie podejście zgodnie z którym osobniki są dołączane do obecnej populacji, która pod koniec obecnego pokolenia jest zmniejszana za pomocą operatora selekcji (opisanego w rozdziale \ref{subsection:natSel}).

\subsubsection{Operator mutacji}
Operator mutacji odpowiada za symulowanie losowych zmian zachodzących w kodzie genetycznym. Jego zadaniem jest sterowanie eksploracją przestrzeni rozwiązań.

Dziedziną tego operatora jest przestrzeń rozwiązań, a przeciwdziedziną - $\variable{m}$krotny iloczyn kartezjański przestrzeni rozwiązań. Oznacza to, że jednokrotne zastosowanie operatora mutacji daje w wyniku $\variable{m}$ osobników powstałych przez modyfikację osobnika pierwotnego. Każdy ze zwróconych osobników powinien być nieznacznie różny od argumentu operatora. 

Jedną z popularnych realizacji tego operatora dla osobnika reprezentowanego jako wektor bitów jest negacja losowych wartości, w wyniku czego otrzymujemy osobniki różniące się od argumentu operatora tylko kilkoma elementami. Na rysunku \ref{vector:example_mutation} zobrazowano działanie takiego podejścia. Wektor $(1, 0, 0, 1, 1, 1, 0, 0, 1, 0)$ to argument operatora. Kolorem zaznaczono losowe pozycje w wektorze, które zostaną zanegowane, w wyniku czego powstanie wektor wyjściowy $(1, \textbf{1}, 0, 1, \textbf{0}, 1, 0, 0, 1, \textbf{1})$.

\begin{figure}[h]
	\caption{Działanie przykładowej realizacji operatora mutacji \label{vector:example_mutation}}
	\centering
	\begin{tikzpicture}[>=triangle 60]
	\tikzstyle{cellStyle}=[draw, rectangle, minimum width=1cm, minimum height=1cm, text centered, draw=black]
	\tikzstyle{mutated}=[cellStyle, fill=gray!50]
	
	%original
	\node[cellStyle] at(0, 0) {$1$};
	\node[mutated] at(1, 0) {$0$};
	\node[cellStyle] at(2, 0) {$0$};
	\node[cellStyle] at(3, 0) {$1$};
	\node[mutated] at(4, 0) {$1$};
	\node[cellStyle] at(5, 0) {$1$};
	\node[cellStyle] at(6, 0) {$0$};
	\node[cellStyle] at(7, 0) {$0$};
	\node[cellStyle] at(8, 0) {$1$};
	\node[mutated] at(9, 0) {$0$};
	
	%operator arrow
	\draw [->, thick] (4.5, -1)  -- (4.5, -3); 
	\node[right] at (4.5, -2) {$\param{operatorMutacji}$};
				
	%mutated
	\node[cellStyle] at(0, -4) {$1$};
	\node[mutated] at(1, -4) {$1$};
	\node[cellStyle] at(2, -4) {$0$};
	\node[cellStyle] at(3, -4) {$1$};
	\node[mutated] at(4, -4) {$0$};
	\node[cellStyle] at(5, -4) {$1$};
	\node[cellStyle] at(6, -4) {$0$};
	\node[cellStyle] at(7, -4) {$0$};
	\node[cellStyle] at(8, -4) {$1$};
	\node[mutated] at(9, -4) {$1$};				
				
	\end{tikzpicture} 
\end{figure}

Z operatorem mutacji ściśle związany jest jeden z parametrów algorytmu ewolucyjnego - prawdopodobieństwo mutacji. Jest to wartość określająca prawdopodobieństwo zastosowania operatora mutacji do osobnika w danym pokoleniu. Jeśli wartość ta jest równa 0, to operator mutacji nie jest w ogóle używany, a jeśli jest równa 1, to operator zostanie zastosowany do każdego osobnika.

\begin{signature}
	\caption{Operator mutacji \label{signature:mutation}}
	\begin{align}
	\param{operatorMutacji}: & \important{S} \rightarrow \important{S}^\variable{m} \\
	\param{prawdopodobienstwoMutacji} \in & [0, 1]
	\end{align}
	$\variable{m}$ to liczba zwracanych wyników mutacji.
\end{signature}	

\subsubsection{Operator krzyżowania} \label{subsection:crossover}

Operator krzyżowania symuluje proces krzyżowania się osobników w naturze. Jego zadaniem jest sterowanie eksploatacją przestrzeni rozwiązań.

Dziedziną tego operatora jest $\inputVar{c}$krotny iloczyn kartezjański przestrzeni rozwiązań, a przeciwdziedziną - $\outputVar{c}$krotny iloczyn tej przestrzeni. Oznacza to, że operator ten przyjmuje $\inputVar{c}$ osobników (nazywanych \emph{rodzicami}) jako argument, a zwraca $\outputVar{c}$ osobników (nazywanych \emph{potomstwem}). Zazwyczaj przyjmuje się $ \inputVar{c} = 2 $ i $\outputVar{c} \in \left\{1, 2 \right\}$. Zwracane osobniki powinny być podobne (w takim sensie, że mają podobną reprezentację) do osobników wejściowych (argumentów operatora). 

Jedną z popularnych realizacji dla osobnika reprezentowanego jako wektor dla $\inputVar{c} = 2$ i $\outputVar{c} = 2$ jest wybranie losowej pozycji w wektorze (tzw. punktu przecięcia) i zwrócenie 2 osobników powstałych przez zamianę podwektorów od wylosowanej pozycji wzwyż. Na rysunku \ref{vector:example_crossover} zobrazowano działanie takiego podejścia. Wektory $(x_0, \ldots, x_9)$ i $(y_0, \ldots, y_9)$ to wektory wejściowe. Grubą linią zaznaczono wylosowany punkt przecięcia, wyznaczający podwektory które zostają zamienione. Wynikiem zastosowania operatora są wektory $(x_0, \ldots, x_3, y_4, \ldots y_9)$ i $(y_0, \ldots, y_3, x_4, \ldots x_9)$.

\begin{figure}[h]
	\caption{Działanie przykładowej realizacji operatora krzyżowania \label{vector:example_crossover}}
	\centering
	\begin{tikzpicture}[>=triangle 60]
		\tikzstyle{cellStyle}=[draw, rectangle, minimum width=1cm, minimum height=1cm, text centered, draw=black]
		\tikzstyle{first}=[cellStyle, fill=gray!30]
		\tikzstyle{second}=[cellStyle, fill=gray!70]
		
		%first input
		\foreach \x in {0,1,...,9}
			\node[first] at (\x, 0) {$x_\x$};
			
		%second input	
		\foreach \x in {0,1,...,9}
			\node[second] at (\x, -1.5) {$y_\x$};
			
		%input cutpoint
		\draw[ultra thick] (3.5, 1) -- (3.5, -2.5);
		
		%operator arrow
		\draw [->, thick] (4.5, -2.5)  -- (4.5, -4.5); 
		\node[right] at (4.5, -3.5) {$\param{operatorKrzyzowania}_{\inputVar{c}=2, \outputVar{c}=2}$};
		
		%first output
		\foreach \x in {0,1,...,3}
			\node[first] at (\x, -5.5) {$x_\x$};
		\foreach \x in {4,5,...,9}
			\node[second] at (\x, -5.5) {$y_\x$};
		
		%second output
		\foreach \x in {0,1,...,3}
			\node[second] at (\x, -7) {$y_\x$};
		\foreach \x in {4,5,...,9}
			\node[first] at (\x, -7) {$x_\x$};
			
		%output cutpoint
		\draw[ultra thick] (3.5, -4.5) -- (3.5, -8);
	\end{tikzpicture} 
\end{figure}

Z operatorem krzyżowania ściśle związany jest jeden z parametrów algorytmu ewolucyjnego - prawdopodobieństwo krzyżowania. Jest to wartość określająca prawdopodobieństwo zastosowania operatora krzyżowania do osobnika w danym pokoleniu. Jeśli wartość ta jest równa 0, to operator krzyżowania nie jest w ogóle używany, a jeśli jest równa 1, to operator zostanie zastosowany do każdego osobnika.

\begin{signature}
	\caption{Operator krzyżowania \label{signature:crossover}}
	\begin{align}
	\param{operatorKrzyzowania}: & \important{S}^\inputVar{c} \rightarrow \important{S}^\outputVar{c} \\
	\param{prawdopodobienstwoKrzyzowania} \in & [0, 1]
	\end{align}
	$\inputVar{c}$ to liczba rodziców, a $\outputVar{c}$ to liczba potomków.
\end{signature}	

\subsection{Operator selekcji} \label{subsection:natSel}

Zadaniem \textbf{operatora selekcji} jest symulacja zjawiska przeżycia silniejszych (czyli lepiej dopasowanych) osobników. Jest on stosowany pod koniec każdego pokolenia w celu usunięcia z niej osobników gorzej dopasowanych, poprzez wykorzystanie populacji wyjściowej jako używanej w kolejnym pokoleniu. Zmniejsza on różnorodność genetyczną w obrębie populacji, co w ogólności jest negatywnym efektem, ponieważ zahamowywuje proces eksplorację przestrzeni rozwiązań. Operator mutacji powinien eksplorować ją na tyle efektywnie, żeby operator selekcji odrzucał mało obiecujące kierunki eksploracji zamiast całkiem zatrzymywać jej proces.

Dziedziną tego operatora jest $p$krotny iloczyn kartezjański przestrzeni rozwiązań, co oznacza, że przyjmuje on populację $p$ osobników. Wartość $p$ to ilość osobników w populacji pod koniec danej generacji, więc można ją przybliżać za pomocą równać z linii \ref{line:p_start}-\ref{line:p_stop} sygnatury \ref{signature:selection}, ponieważ w populacji znajdą się osobniki z populacji początkowej tego pokolenia oraz wyniki operatorów mutacji i krzyżowania. 

Przeciwdziedziną operatora selekcji jest $\param{rozmiarPopulacji}$krotny iloczyn kartezjański przestrzeni rozwiązań, co oznacza, że wynikiem działania operatora powinien być zbiór $\param{rozmiarPopulacji}$ osobników. Wartość $\param{rozmiarPopulacji}$ to parametr całej heurystyki, określająca jak liczna powinna być populacja na początku każdego pokolenia. Im większą wartość przyjmuje ten parametr, tym lepsze przeszukiwanie przestrzeni rozwiązań, ale też tym dłużej trwa sama heurystyka (ponieważ trzeba ewaluować więcej osobników i do większej liczby z nich zastosować operatory genetyczne). 

Dodatkowo na operator nakłada się wymóg opisany w liniach \ref{line:constraint_sel_start}-\ref{line:constraint_sel_stop} sygnatury \ref{signature:selection}. Mówią one o tym, że prawdopodobieństwo tego, że osobnik z populacji wejściowej znajdzie się w populacji wyjściowej powinno być tym większe im lepiej dopasowany jest osobnik. Ma to symulować zasadę przetrwania osobników najlepiej przystosowanych do środowiska.

Najprostsza realizacja takiego operatora polega na posortowaniu populacji pod kątem wartości funkcji oceny (w kolejności rosnącej dla zadania minimalizacji lub malejącej dla zadania maksymalizacji) i zwrócenia najlepszych $\param{rozmiarPopulacji}$ osobników. Takie podejście jest czasami nazywane operatorem elitystycznym lub elitarnym. Mimo tego, że wydaje się ono intuicyjne, to praktyka pokazuje, że nie daje ono tak dobrych wyników jak realizacje które nie zawsze zwracają populację zawierającą najlepszego osobnika. Operator elitarny ma tendencję do szybkiego doprowadzania do stagnacji, ponieważ nie pozwala nowym osobnikom (wynikom mutacji lub krzyżowania) na przeżycie, co skutkuje zahamowaniem eksploracji przestrzeni rozwiązań.

\begin{signature}
	\caption{Operator selekcji \label{signature:selection}}
	\begin{align}
	\param{operatorSelekcji}: &\important{S}^p \rightarrow \important{S}^{\param{rozmiarPopulacji}} \\
	\param{rozmiarPopulacji} \in &\numberSet{N}_{+} \\
	\label{line:p_start} 
	p \approx &(1 + \param{prawdopodobienstwoMutacji} \times \variable{m} \\
	          &+ \param{prawdopodobienstwoKrzyzowania} \times \outputVar{c}) \\
	\label{line:p_stop} 
	&\times \param{rozmiarPopulacji} \\
	\label{line:constraint_sel_start}          
	T \gets &\left\{ t_0, t_1, \ldots t_{\param{rozmiarPopulacji}-1} \right\} \\
	s \in \param{operatorSelekcji}(T) &\Leftrightarrow \exists_{t \in T}  t \equiv s \\
	P(i) \gets &P(t_i \in \param{operatorSelekcji}(T)) \\
	\label{line:constraint_sel_stop} 
	P(i) < P(j) &\Leftrightarrow (t_i, t_j) \in \minoritySpecimenRel
	\end{align}
\end{signature}

\subsection{Warunek stopu} \label{subsection:stop}

\textbf{Warunek stopu}, nazywany też warunkiem zatrzymania lub przerwania to pojęcie określające warunek zakończenia heurystyki. Jest to odpowiedź na pytanie ,,kiedy należy przestać przetwarzanie kolejnych pokoleń?''. Często stosuje się takie kryteria jak przekroczenie jakiejś arbitralnej liczby pokoleń, lub zaobserwowanie tzw. stagnacji. Zjawisko takie polega na znacznym zmniejszeniu różnorodności ocen w populacji, co oznacza, że znaleźliśmy optimum lokalne. Jeśli wariancja ocen przez kilka pokoleń się nie zmienia (lub zmienia, ale nie znacząco), to można uznać, że operatory genetyczne nie pozwolą na wyjście z tego optimum i przerwać działanie heurystyki. 
Warunek zatrzymania możemy traktować jako dodatkowy operator, jednak trudno jest określić jego jednoznaczną sygnaturę, ze względu na dowolność realizacji. W sygnaturze \ref{signature:stop} przedstawiono ogólny zapis operatora (z dowolną dziedziną, linia \ref{line:stop_general}) i sygnaturę jego przykładowej realizacji (opartej o stałą liczbę pokoleń, linia \ref{line:stop_maxGen}).

\begin{signature}
	\caption{Warunek zatrzymania i jego przykładowa realizacja \label{signature:stop}} 
	\begin{align}
		\label{line:stop_general}
		\param{warunekStopu}: &\ldots \rightarrow \left\{ 0, 1 \right\}
	\end{align}
	\begin{align}
		\label{line:stop_maxGen}
		\param{warunekStopu}: &\numberSet{N} \rightarrow \left\{ 0, 1 \right\} \\
		\param{warunekStopu}(g) = &1 \Leftrightarrow g \leq \overline{\variable{g}}
	\end{align}
	Zwrócenie wartości $1$ oznacza, że należy zakończyć działanie heurystyki, a $0$ - sytuację odwrotną. \\ 
	Wartość $g$ oznacza numer obecnego pokolenia (zaczynając od 1), a $\overline{\variable{g}}$ - maksymalną dopuszczalną liczbę pokoleń w ramach jednego przebiegu algorytmu ewolucyjnego.
\end{signature}	

\clearpage

\subsection{Schemat algorytmu} \label{subsection:general_ea_scheme}

Na rysunku \ref{figure:flowchart_conventions} zobrazowane zostały różne elementy schematów blokowych używane w tej pract, opisane w tabeli \ref{table:flowchart_conventions}. Ponadto, w algorytmach używany jest operator $random(X)$ opisany sygnaturą \ref{signature:random}, zwracający losowy element zbioru $X$ (z rozkładem równomiernym).

\begin{signature}
	\caption{Operator $random(S)$ \label{signature:random}}
	\begin{align}
	random: &A^n \rightarrow A \\
	n \in &\numberSet{N}_{+} \\
	X \gets &\left\{ x_0, x_1, \dots x_{n-1} \right\} \\
	\forall_{x_i, x_j \in X} P(random(X) = x_i) = &P(random(X) = x_j)
	\end{align}
	$A$ to dowolny zbiór, a $n$ jego rozmiar.
\end{signature}

\begin{figure}[H]
	\caption{Elementy schematów blokowych używane w tej pracy \label{figure:flowchart_conventions}}
	\img{conventions.png}
\end{figure}

\clearpage

\begin{table}[H]
	\caption{Opis konwencji dotyczących elementów schematów blokowych \label{table:flowchart_conventions}}
	\begin{tabularx}{\linewidth}{|c|X|}
		\hline 
		\circled{1} & Symbol rozpoczęcia heurystyki. \\
		\hline
		\circled{2} & Symbol rozpoczęcia heurystyki. \\
		\hline
		\circled{3} & Symbol oznaczający ewaluację warunku C i kontynuację procesu zgodnie z jego wynikiem. \\
		\hline
		\circled{4} & Symbol oznaczający wykonanie kroku opisanego przez S. \\
		\hline
		\circled{5} & Symbol tożsamy z symbolem \circled{4}, jednak stosowany w opisie proponowanego podejścia dla zaznaczenia różnic ze standardowym schematem (używane w rozdziale \ref{chapter:proposed}).\\
		\hline
		\circled{6} & Taka kombinacja symboli oznacza, że podczas wykonywania kroku S używany jest operator O. \\
		\hline
		\circled{7} & Taka kombinacja symboli oznacza, że podczas wykonywania kroku S używany jest parametr P. \\
		\hline
		\circled{8} & Symbol oznaczający, że dany schemat wyjaśnia szczegółowe działanie kroku D. \\
		\hline
		\circled{9} & Symbol oznaczający rozpoczęcie lub zakończenie szczegółowo opisywanego kroku. \\
		\hline
		\circled{10} & Symbol oznaczający wykonanie kolejnego symbolu dla każdego z elementów opisanych przez E. \\
		\hline
	\end{tabularx}
\end{table}

\clearpage

Na rysunku \ref{figure:ea_general} zobrazowany został ogólny schemat działania algorytmów ewolucyjnych. 

\begin{figure}
	\caption{Ogólny schemat działania algorytmów ewolucyjnych \label{figure:ea_general}}
	\img{ea_general.png}
\end{figure}

Cały proces rozpoczyna się od inicjalizacji populacji przy pomocy losowych osobników. Następnie, póki warunek zatrzymania nie jest spełniony, powtarzane jest kilka kroków wykonywanych w ramach jednego pokolenia. Są to kolejno: krzyżowanie, mutacja i selekcja naturalna.

\begin{algorithm}[H]
	\caption{Szczegółowy schemat działania kroku "Wykonaj krzyżowanie"	\label{algorithm:crossOver_std}}
	\begin{algorithmic}[1]
		\Params{
			$populacja$ 
				\Comment{Obecna populacja, tj. zbiór osobników}\\ 
			$\param{prawdopodobienstwoKrzyzowania}$
				\Comment{Prawd. krzyżowania}\\ 
			$\param{operatorKrzyzowania}$  
				\Comment{Operator krzyżowania}
			}
		\Procedure{crossingOver}{}
			\Var $noweOsobniki \gets \emptyset$
			\ForAll {$osobnik \in populacja$}
				\If {$random([0,1]) \leq \nicefrac{\param{prawdopodobienstwoKrzyzowania}}{2}$}
					\Var $partner \gets random(populacja \setminus \left\{ osobnik \right\})$ 
					\Var $potomek \gets \param{operatorKrzyzowania}(osobnik, partner)$
					\State $noweOsobniki \gets noweOsobniki \cup \left\{ potomek \right\}$
				\EndIf 
			\EndFor
			\State $populacja \gets populacja \cup noweOsobniki$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Algorytm \ref{algorithm:crossOver_std} opisuje szczegóły kroku "Wykonaj krzyżowanie". Krok ten rozpoczyna się od inicjalizacji zmiennej $noweOsobniki$ na pusty zbiór (w linii 2.), który w linii 10. zostanie dołączony do ogólnej populacji. Dla każdego osobnika w populacji (linia 3) sprawdzane jest, czy należy wykonać krzyżowanie z jego udziałem (linia 4). Jeżeli tak, to losowo dobierany jest jego partner (linia 5), a następnie na tak określonej parze osobników stosowany jest operator krzyżowania, którego wynik jest dołączany do zbioru $noweOsobniki$. Schemat ten przewiduje, że operator krzyżowania przyjmuje 2 osobniki jako argument (tzn. $n = 2$, patrz: rozdział \ref{subsection:crossover}), przez co wartość, z którą porównujemy losowo wybraną liczbę z przedziału $[0, 1]$ to $\nicefrac{\param{prawdopodobienstwoKrzyzowania}}{2}$. W ogólności, dla dowolnego $n$ wartość ta wynosi $\nicefrac{\param{prawdopodobienstwoKrzyzowania}}{n}$, a zamiast jednego partnera należy wybrać ich $n-1$.

\begin{algorithm}[H]
	\caption{Szczegółowy schemat działania kroku "Wykonaj mutację"	\label{algorithm:mutation_std}}
	\begin{algorithmic}[1]
		\Params{
			$populacja$ 
			\Comment{Obecna populacja, tj. zbiór osobników}\\ 
			$\param{prawdopodobienstwoMutacji}$
			\Comment{Prawd. mutacji}\\ 
			$\param{operatorMutacji}$  
			\Comment{Operator mutacji}
		}
		\Procedure{mutation}{}
		\Var $noweOsobniki \gets \emptyset$
		\ForAll {$osobnik \in populacja$}
			\If {$random([0,1]) \leq \param{prawdopodobienstwoMutacji}$}
				\Var $mutant \gets \param{operatorMutacji}(osobnik)$
				\State $noweOsobniki \gets noweOsobniki \cup \left\{ mutant \right\}$
			\EndIf 
		\EndFor
		\State $populacja \gets populacja \cup noweOsobniki$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Algorytm \ref{algorithm:mutation_std} opisuje szczegóły kroku "Wykonaj mutację". Krok rozpoczyna się od inicjalizacji zmiennej $noweOsobniki$ na pusty zbiór (w linii 2.), który w linii 9. zostanie dołączony do ogólnej populacji. Dla każdego osobnika w populacji (linia 3) sprawdzane jest, czy należy wykonać na nim mutację (linia 4), a jeśli tak, to stosowany jest do niego operator mutacji, którego wynik zostaje dołączony do zbioru $noweOsobniki$ (linie 5 i 6).

\begin{algorithm}[H]
	\caption{Szczegółowy schemat działania kroku "Dokonaj selekcji naturalnej"	\label{algorithm:natSel_std}}
	\begin{algorithmic}[1]
		\Params{
			$populacja$ 
			\Comment{Obecna populacja, tj. zbiór osobników}\\ 
			$\param{rozmiarPopulacji}$
			\Comment{Rozmiar populacji}\\ 
			$\param{operatorSelekcji}$  
			\Comment{Operator selekcji}
		}
		\Procedure{naturalSelection}{}
		\State $populacja \gets \param{operatorSelekcji}_{\param{rozmiarPopulacji}}(populacja)$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Algorytm \ref{algorithm:natSel_std} opisuje szczegóły kroku "Dokonaj selekcji naturalnej", który \defacto sprowadza się do zastąpienia dotychczasowej populacji wynikiem zastosowania operatora selekcji na niej (linia 1).

\clearpage

Tak zdefiniowany proces służy do efektywnego przeszukiwania przestrzeni rozwiązań, tymczasem zadanie optymalizacji ma na celu znalezienie jednego, jak najlepszego rozwiązania. Oznacza to, że jedno z rozwiązań, które zostanie zbadane w trakcie działania heurystyki musi być zapamiętane i zwrócone jako wynik. Naiwnym podejściem jest analiza populacji po ostatnim pokoleniu i zwrócenie najlepszego z osobników. Jako że operator selekcji nie gwarantuje tego, że w zbiorze wynikowym znajdzie się najlepszy osobnik ze zbioru wejściowego, to istnieje szansa, że najlepsze rozwiązanie z ostatniej populacji nie jest najlepszym rozwiązaniem znalezionym w trakcie działania heurystyki. Zamiast tego podczas działania heurystyki zapamiętujemy globalnie najlepsze rozwiązanie na jakie trafiliśmy i właśnie je traktujemy jako rozwiązanie problemu optymalizacji. Zazwyczaj realizuje się to w ten sposób, że definiuje się zmienną przechowującą globalne optimum, która początkowa ma wartość pustą. Po zakończeniu pierwszego pokolenia, ale przed zastosowaniem operatora selekcji zapisuje się w niej najlepsze rozwiązanie w tym pokoleniu. W dalszych pokoleniach, również przed zastosowaniem operatora selekcji, porównuje się ocenę obecnego globalnego optimum i najlepszego osobnika z danego pokolenia (optimum lokalnego). Jeśli optimum lokalne jest lepsze niż globalne, to zastępuje je ono.

\section{Analiza jakości działania}

Algorytmy ewolucyjne to rodzina losowych, iteracyjnych heurystyk populacyjnych. Określenie ,,losowych'' oznacza, że każde uruchomienie procesu optymalizacji może zwrócić inny wynik. Co za tym idzie, ocena działania heurystyki dla danego zestawu parametrów jest trudna i wymaga wielokrotnego zebrania wyników. W następnych rozdziałach opisane zostaną sposoby analizy jakości działania pojedynczego przebiegu heurystyki, jak i wielu przebiegów o tych samych parametrach.

\subsection{Analiza jednego przebiegu heurystyki}

Jak było wspomniane wyżej, algorytmy ewolucyjne to iteracyjne heurystyki populacyjne. Oznacza to, że w ramach jednego procesu optymalizacji wielokrotnie powtarzamy pewien krok (stąd określenie ,,iteracyjne'') w którym badamy wiele rozwiązań (stąd określenie ,,populacyjne'').

Aby ocenić pojedynczy przebieg, możemy analizować pewne statystyki oceny w skali populacji na przestrzeni wielu pokoleń.

Podstawowe statystyki używane w tym celu, to m.in.:
\begin{itemize}
	\item najlepsza i najgorsza ocena osobnika z populacji,
	\item średnia i odchylenie standardowe (lub wariancja \footnote{Często wariancji używa się do automatyzacji oceny, ponieważ obliczenie jej nie wymaga czasochłonnego pierwiastkowania. Znając wariancję w dowolnym momencie możemy obliczyć odchylenie standardowe, np. w celu prezentacji oceny.  \label{footer:variance}}) oceny osobników w populacji,
	\item mediana i kwantyle oceny osobników w populacji.
\end{itemize}

Wartości te można wygodnie zobrazować na wykresie pudełkowym, na osi odciętych umieszczając numery pokoleń, a na osi rzędnych - wartości odpowiednich statystyk. Takie zobrazowanie przebiegu heurystyki pozwala na wyciągnięcie wniosków i stosowne dopasowanie parametrów heurystyki (np. jeśli w problemie minimalizacji wszystkie wartości stopniowo maleją, to być może warto zwiększyć rozmiar populacji lub zmienić kryterium zatrzymania, aby cały proces trwał dłużej, ponieważ taka obserwacja wskazuje na efektywne działanie heurystyki).

W tej pracy do analizy wykorzystano tylko 4 z wyżej wymienionych statystyk: średnią, wariancję\footnote{Zdecydowano się na wykorzystanie wariancji zamiast odchylenia standardowego ponieważ wartości odchylenia okazały się być zbyt małe, aby były dostrzegalne na wykresach.}, minimum i maksimum. Są one w pełni wystarczające do analizy porównawczej między uruchomieniami. Na rysunku \ref{plot:conventions} przedstawiono konwencje dotyczące rysowania wykresów przyjęte w tym dokumencie.

\begin{figure}[H]
	\caption{Konwencje dotyczące rysowania wykresów \label{plot:conventions}}
	\centering
	\graph{example_whiskers.tex}
\end{figure}

%\clearpage

\begin{figure}[H]
	\caption{Przykładowy wykres przebiegu \label{plot:random_example}}
	\centering
	\graph{random_example.tex}
\end{figure}

Na rysunku \ref{plot:random_example} przedstawiony jest przykładowy wykres statystyk populacji na przestrzeni wielu pokoleń. Wykresy takie, nazywane w skrócie \emph{wykresami przebiegów}, będą wykorzystywane w tej pracy do analizy pojedynczych uruchomień heurystyki. 

\begin{figure}[H]
	\caption{Wykres przebiegu, w którym globalne optimum nie znajduje się w ostatniej populacji \label{plot:mid_opt}}
	\centering
	\graph{mid_optimum.tex}
\end{figure}

Na rysunku \ref{plot:mid_opt} przedstawiony jest wykres przebiegu na którym możemy zaobserwować sytuację opisaną na końcu rozdziału \ref{subsection:general_ea_scheme}, tzn. taką, w której optimum globalne jest znalezione w innym pokoleniu niż ostatnie.

\begin{figure}[H]
	\caption{Wykres przebiegu w którym obserwujemy stagnację \label{plot:stagnation}}
	\centering
	\graph{stagnation.tex}
\end{figure}

Na rysunku \ref{plot:stagnation} przedstawiono sytuację, w której obserwujemy tzw. stagnację (wspominaną już w rozdziale \ref{subsection:stop}). Możemy zaobserwować, że od pewnego momentu (około sześćdziesiątej generacji) kolejne pokolenia nie przynoszą znaczącej zmiany wyniku, co mogłoby być powodem do przerwania działania heurystyki.

\subsection{Analiza wielu przebiegów heurystyki}

Jak zostało wspomniane na początku tego rozdziału, algorytmy ewolucyjne to heurystyki losowe, przez co za każdym uruchomieniem zwracają różne wartości. Aby ocenić wyniki procesu optymalizacji dla różnych zestawów parametrów należy kilkukrotnie powtórzyć proces i porównywać statystyki wyników. Jeśli jesteśmy w trakcie dostrajania heurystyki (czyli dobierania najlepszych parametrów), to taką statystyką może być najlepszy wynik z kilku powtórzeń, jednak jeśli chcemy przeprowadzić miarodajne badania, to najprostszym podejściem dającym wgląd w jakość działania jest obliczenie średniej i wariancji (lub odchylenia standardowego, patrz: przypis \ref{footer:variance}) wyników wielu przebiegów dla różnych konfiguracji i porównanie ich testem statystycznym, takim jak np. test t-studenta.

\chapter{Przegląd literatury} \label{chapter:literature}

\chapter{Proponowane rozwiązania} \label{chapter:proposed}

Dotychczasowe implementacje algorytmów ewolucyjnych zazwyczaj (choć nie zawsze \cite{GGA}, \cite{SexualGA}) pomijały ważny aspekt procesu ewolucji, który w przyrodzie okazuje się mieć duży wpływ na dopasowywanie się gatunków do środowiska - podział gatunku na płcie. W rzeczywistości większa część istniejących gatunków, zaczynając od dość prostych (jak owady, czy rośliny), a kończąc na złożonych (takich jak ssaki), do rozmnażania potrzebują dwóch rodziców różniących się konkretnym chromosomem. Różnica ta jest powodem istnienia całego zespołu cech, które pozwalają podzielić osobniki na żeńskie i męskie, a w ogólności na osobniki różnych płci. Mimo, że nie jest to spotykane w naturze, to w ramach eksperymentu myślowego można założyć dowolną liczbę płci, a nie tylko dwie.

Przy opisywaniu operatorów wprowadzanych w tym rozdziale, używana będzie funkcja $plec(osobnik)$, przypisująca osobnikowi jego płeć. 

\begin{signature}
	\caption{Funkcja $plec(osobnik)$ \label{signature:genderFoo}}
	\begin{align}
	plec: & \important{S} \rightarrow \important{G} \\
	\important{G} \neq & \emptyset
	\end{align}
	$\important{G}$ to zbiór możliwych płci.
\end{signature}


\section{Heurystyka DSEA} \label{section:dsea}

Jak zostało pokazane w rozdziale \ref{chapter:literature}, istnieją rozwiązania które nie ignorują podziału populacji na płcie. Aby skutecznie je porównać i zaproponować nowe podejście, zdefiniowano schemat działania heurystki, opisany schematem blokowym znajdującym się na rysunku \ref{figure:dsea}. Ujmuje on wyżej opisany aspekt biologii organizmów w ramach nowego operatora genetycznego. W dalszej części pracy tak zdefiniowaną heurystykę nazywać będziemy \textbf{algorytmem ewolucyjnym o podwójnej selekcji} (ang. \emph{double selection evolutionary algorithm}) i odnosić się do niej przy pomocy skrótu \textbf{DSEA}, będącego akronimem nazwy angielskiej.

\subsection{Działanie} \label{subsection:dsea_scheme}

Na rysunku \ref{figure:dsea} przedstawiono schemat działania heurystyki DSEA w postaci schematu blokowego\footnote{Konwencje dotyczące elementów schematów przedstawionych w całości pracy zostały przedstawione na rysunku \ref{figure:flowchart_conventions} w rozdziale \ref{subsection:general_ea_scheme}.}. 

\begin{figure}[H]
	\caption{Schemat działania heurystyki DSEA \label{figure:dsea}}
	\img{dsea.png}
\end{figure}

W większej części diagram zgadza się z diagramem \ref{figure:ea_general} przedstawionym w rozdziale \ref{subsection:general_ea_scheme}. Istotne różnice między diagramami to zmiana działania kroku "Wykonaj krzyżowanie oraz dodanie nowego kroku "Zadbaj o różnorodność populacji" zaraz przed nim. Zostały one zdefiniowane w rozdziałach kolejno \ref{subsubsection:my_crossover} i  i \ref{figure:fixing}. Ponadto, zmieniła się nazwa operatora używanego w kroku "Dokonaj selekcji naturalnej", co zostanie opisane w rozdziale \ref{subsection:new_natSel}.

\subsubsection{Krok ,,Wykonaj krzyżowanie''} \label{subsubsection:my_crossover}


Na rysunku \ref{figure:my_crossover} znajduje się diagram przedstawiający krok "Wykonaj krzyżowanie" jako sekwencję mniejszych kroków. Za pomocą operatora selekcji płciowej\footnote{W rozdziale \ref{subsection:new_genSel} opisane zostanie znaczenie i sygnatura tego operatora, wyjaśnione jest uproszczenie polegające na zwracaniu par rodziców oraz różnica w interpretacji parametru $\param{prawdopodobienstwoKrzyzowania}$. } generowana jest lista par rodziców. Następnie, dla każdej z nich wykonuje się krzyżowanie, traktując oba osobniki z pary jako argumenty operatora krzyżowania, a jego wynik dołączając do populacji. W przeciwieństwie do realizacji opisanej w rozdziale \ref{subsection:general_ea_scheme} przy pomocy algorytmu \ref{algorithm:crossOver_std} wyniki operatora krzyżowania nie są dołączane do osobnego zbioru, a od razu do całości populacji. Jest tak, ponieważ zadanie wyboru rodziców jest oddelegowane do operatora, który zawsze zostanie użyty przed operatorem krzyżowania.

\begin{figure}[H]
	\caption{Szczegóły działania kroku ,,Wykonaj krzyżowanie'' \label{figure:my_crossover}}
	\img{my_crossover.png}
\end{figure}

\subsubsection{Krok ,,Zadbaj o różnorodność populacji''} \label{subsubsection:fixing}

Wprowadzenie podziału populacji na płcie powinno skutkować odmiennym traktowaniem osobników w zależności od tej cechy. Co za tym idzie, obie podgrupy powinny różnić się tym bardziej, im więcej generacji zostało przeprowadzonych. Efekt taki ma zarówno wady, jak i zalety. Dzięki niemu potomstwo (czyli wynik operatora krzyżowania) w danej populacji powinno również zachować większą różnorodność. Negatywną stroną tego zjawiska jest fakt, że operator selekcji naturalnej, który nie powinien brać pod uwagę płci, może zaburzyć stosunek liczności osobników danych płci względem siebie. W skrajnych sytuacjach może dojść do tego, że w całej populacji zabraknie osobników którejś z płci, co uniemożliwi dalsze działanie heurystyki (ponieważ niemożliwe byłoby zastosowanie operatora krzyżowania). Ponadto, im dysproporcje między różnymi płciami będą większe, tym mniejsza będzie różnorodność całej populacji, co szybko prowadzi do stagnacji.

\begin{figure}[H]
	\caption{Szczegóły działania kroku ,,Zadbaj o różnorodność populacji'' \label{figure:fixing}}
	\img{fixing.png}
\end{figure}

Na rysunku \ref{figure:fixing} przedstawiono krok mający ograniczyć negatywne efekty podziału na płcie, opisane wyżej. 

W pierwszej jego części do populacji dodajemy tzw. ,,domieszki'' (ang. \emph{mixins}), czyli losowe osobniki (tworzone w ten sam sposób co populacja początkowa). Ma to na celu regularne uzupełnianie puli genów obecnych w populacji, na wypadek gdyby geny odpowiedzialne za pozytywną cechę zanikły z powodu losowości operatora selekcji naturalnej lub płciowej. Ilość domieszek jest kontrolowana przez współczynnik domieszek ($\param{wspDomieszek}$), będący stosunkiem pożądanej ilości nowych osobników do wartości $\param{rozmiarPopulacji}$.

Druga część kroku ma zapobiec sytuacjom, w których któraś płeć nie występuje w populacji, lub jest zbyt słabo reprezentowana. Jeśli liczność którejś z płci w populacji spadnie poniżej arbitralnie dobranej liczby $\param{d}$, to do populacji dołączane jest co najmniej $\param{d}$, a co najwyżej $\lceil \param{wspSamorodków} \times \param{rozmiarPopulacji} \rceil$ losowych osobników tej płci\footnote{Alternatywnym rozwiązaniem mogłaby być zmiana płci losowych osobników pozostałych płci.}. W praktyce, w ramach tej pracy użyto arbitralnie dobranych wartości $\param{d} = 5$ i $\param{wspSamorodków} = 0.05$.

\subsection{Operator selekcji naturalnej} \label{subsection:new_natSel}

Heurystyka DSEA, jak nazwa wskazuje, korzysta z dwóch operatorów selekcji, które należy rózróżnić. Z tego powodu dotychczasowy operator selekcji zmienił nazwę na \textbf{operator selekcji naturalnej}. Zachowuje on to samo znaczenie i zastosowanie, opisane w rozdziale \ref{subsection:natSel}. 

Dodatkowo, wymaga się, aby prawdopodobieństwo znalezienia się osobnika w zbiorze zwracanym przez ten operator było niezależne od płci osobnika. Zostało to zapisane w linii \ref{line:gender_resistant} sygnatury \ref{signature:natSel}, korzystając z twierdzenia zgodnie z którym prawdopodobieństwo łączne dwóch zdarzeń jest równe iloczynowi ich prawdopodobieństw wtedy i tylko wtedy, gdy są to zdarzenia niezależne.

\begin{signature}
	\caption{Operator selekcji naturalnej \label{signature:natSel}}
	\begin{align}
	\param{operatorSelekcji}: &\important{S}^p \rightarrow \important{S}^{\param{rozmiarPopulacji}} \\
	\param{rozmiarPopulacji} \in &\numberSet{N}_{+} \\
	p \approx &(1 + \param{prawdopodobienstwoMutacji} \times \variable{m} \\
	&+ \param{prawdopodobienstwoKrzyzowania} \times \outputVar{c}) \\
	&\times \param{rozmiarPopulacji} \\
	T \gets &\left\{ t_0, t_1, \ldots t_{\param{rozmiarPopulacji}-1} \right\} \\
	s \in \param{operatorSelekcji}(T) &\Leftrightarrow \exists_{t \in T}  t \equiv s \\
	P(i) \gets &P(t_i \in \param{operatorSelekcji}(T)) \\
	\forall_{i, j = 0, 1, \ldots, \param{rozmiarPopulacji}-1}P(i) < P(j) &\Leftrightarrow (t_i, t_j) \in \minoritySpecimenRel \\
	\label{line:gender_resistant}
	\forall_{i= 0, 1, \ldots, \param{rozmiarPopulacji}-1, g \in \important{G}}P(i \wedge & plec(t) = g) = P(i) \times P(plec(t_i) = g)
	\end{align}
\end{signature}

Standardowo korzysta się z operatorów selekcji naturalnej które w konkretny dla siebie sposób wybierają odpowiednią ilość osobników z populacji wejściowej. O ile sam sposób wyboru różni się między realizacjami operatora, to kolejne osobniki dołączające do populacji wyjściowej są zazwyczaj wybierane w ten sam sposób. Pozwala to na zapisanie 

\todo{ta sama semantyka, ściślejsza nazwa, powtórzyć sygnature, opisać realizację opartą o op. wyboru}

\subsubsection{Operator wyboru}

\todo{Wyjaśnić sens, przedstawić sygnaturę, opisać przykładowe, powiedzieć, że ich realizacja jest w eksperymentach}

\subsection{Operator selekcji płciowej} \label{subsection:new_genSel}

\todo{nowe toto, wyjaśnić po co, sygnatura}

\subsection{Realizacja wybranych \todo{rozwiązań literaturowych (?)} w modelu DSEA}

\todo{troche prozy, wspólna realizacja}

\subsubsection{GGA}

\todo{Działanie, realizacja genSel, tuning innych elementów, żeby pasowało}

\subsubsection{SexualGA}

\todo{Działanie, realizacja genSel, tuning innych elementów, żeby pasowało}

\section{Proponowany operator selekcji płciowej}

\todo{Motywacja, działanie}

\subsection{Realizacja}

\todo{algorytm}

\chapter{Eksperymenty}
\section{Implementacja}
\subsection{Komponenty niezależne od problemu}
\subsection{TSP}
działanie operatorów, etc
\subsection{Knapsack}
...
\subsection{(?)}
...
\section{Procedury eksperymentów}
eksploracja z nawrotami/czysty przegląd/inne procedury z etapu 2
\section{Przeprowadzone eksperymenty}
Wyjaśnić strukture
\subsection{TSP}
\subsubsection{Initial}
\paragraph{Konfiguracja}
zakresy parametrów, parametry początkowe, ilość nawrotów i powtórzeń
\paragraph{Przebieg}
Kolejno znajdowane konfiguracje
\paragraph{Wyniki}
10 najlepszych max, 10 najlepszych avg, zestawić w tabelki, opisać
1 najlepszy pokazać i opisać przebieg
\subsubsection{Tweak}
...
\subsubsection{Compare}
...
\subsubsection{SexualGA}
... - co tu będzie?
\subsubsection{GGA}
... - jw?
\subsection{Knapsack}
...
\subsection{(?)}
...

\chapter{Wnioski i spostrzeżenia}
\chapter{Dalsze drogi rozwoju}



\pagestyle{plain}

\todo{wywalić listy (?), poradzić sobie z podwójną bibliografią (patrz: spis treści)}

\listoffigures
\listoftables
\listof{signature}{Spis sygnatur}

\bibliographystyle{iisthesis}
\bibliography{bibliografia}

\end{document}

